<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Equity securities · VLQuantitativeFinancePackage</title><meta name="title" content="Equity securities · VLQuantitativeFinancePackage"/><meta property="og:title" content="Equity securities · VLQuantitativeFinancePackage"/><meta property="twitter:title" content="Equity securities · VLQuantitativeFinancePackage"/><meta name="description" content="Documentation for VLQuantitativeFinancePackage."/><meta property="og:description" content="Documentation for VLQuantitativeFinancePackage."/><meta property="twitter:description" content="Documentation for VLQuantitativeFinancePackage."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">VLQuantitativeFinancePackage</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Instruments</span><ul><li><a class="tocitem" href="../fixed/">Treasury securities</a></li><li class="is-active"><a class="tocitem" href>Equity securities</a><ul class="internal"><li><a class="tocitem" href="#Computing-returns"><span>Computing returns</span></a></li><li><a class="tocitem" href="#Lattice-Models"><span>Lattice Models</span></a></li><li><a class="tocitem" href="#Geometric-Brownian-Motion"><span>Geometric Brownian Motion</span></a></li><li><a class="tocitem" href="#Advanced-Stochastic-Pricing-and-Return-Models"><span>Advanced Stochastic Pricing and Return Models</span></a></li><li><a class="tocitem" href="#Structured-State-Space-Models"><span>Structured State-Space Models</span></a></li></ul></li><li><a class="tocitem" href="../derivatives/">Derivative securities</a></li></ul></li><li><a class="tocitem" href="../portfolio/">Portfolio management</a></li><li><span class="tocitem">Decisions</span><ul><li><a class="tocitem" href="../markov/">Markov models</a></li><li><a class="tocitem" href="../bandits/">Bandits</a></li><li><a class="tocitem" href="../RL/">Reinforcement learning</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Instruments</a></li><li class="is-active"><a href>Equity securities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Equity securities</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/main/docs/src/equity.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Equity-Securities"><a class="docs-heading-anchor" href="#Equity-Securities">Equity Securities</a><a id="Equity-Securities-1"></a><a class="docs-heading-anchor-permalink" href="#Equity-Securities" title="Permalink"></a></h1><p>This should update now.</p><h2 id="Computing-returns"><a class="docs-heading-anchor" href="#Computing-returns">Computing returns</a><a id="Computing-returns-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-returns" title="Permalink"></a></h2><p>Fill me in.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.log_growth_matrix" href="#VLQuantitativeFinancePackage.log_growth_matrix"><code>VLQuantitativeFinancePackage.log_growth_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function log_growth_matrix(dataset::Dict{String, DataFrame}, 
            firms::Array{String,1}; Δt::Float64 = (1.0/252.0), risk_free_rate::Float64 = 0.0) -&gt; Array{Float64,2}</code></pre><p>The <code>log_growth_matrix</code> function computes the excess log growth matrix for a given set of firms where we define the log growth as:</p><p class="math-container">\[    \mu_{t,t-1}(r_{f}) = \frac{1}{\Delta t} \log\left(\frac{S_{t}}{S_{t-1}}\right) - r_f\]</p><p>where <span>$S_t$</span> is the volume weighted average price (units: USD/share) at time <code>t</code>, <span>$\Delta t$</span> is the time increment (in years), and <span>$r_f$</span> is the annual risk-free rate (units: 1/years) assuming continuous compounding.</p><p><strong>Arguments</strong></p><ul><li><code>dataset::Dict{String, DataFrame}</code>: A dictionary of data frames where the keys are the firm ticker symbols and the values are the data frames holding price data. We use the <code>volume_weighted_average_price</code> column to compute the log growth by default.</li><li><code>firms::Array{String,1}</code>: An array of firm ticker symbols for which we want to compute the log growth matrix.</li><li><code>Δt::Float64</code>: The time increment used to compute the log growth. The default value is <code>1/252</code>, i.e., one trading day in units of years.</li><li><code>risk_free_rate::Float64</code>: The risk-free rate used to compute the log growth. The default value is <code>0.0</code>.</li><li><code>keycol::Symbol</code>: The column in the data frame to use to compute the log growth. The default value is <code>:volume_weighted_average_price</code>.</li><li><code>testfirm::String</code>: The firm ticker symbol to use to determine the number of trading days. By default, we use &quot;AAPL&quot;.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Float64,2}</code>: An array of the excess log growth values for the given set of firms. The time series is the rows and the firms are the columns. The columns are ordered according to the order of the <code>firms</code> array.</li></ul><p><strong>See:</strong></p><ul><li>The <code>DataFrame</code> type (and methods for working with data frames) is exported from the <a href="https://dataframes.juliadata.org/stable/">DataFrames.jl package</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Base.jl#L2-L28">source</a></section><section><div><pre><code class="language-julia hljs">function log_growth_matrix(dataset::Dict{String, DataFrame}, 
            firm::String; Δt::Float64 = (1.0/252.0), risk_free_rate::Float64 = 0.0) -&gt; Array{Float64,1}</code></pre><p>The <code>log_growth_matrix</code> function computes the excess log growth matrix for a given firm where we define the log growth as:</p><p class="math-container">\[    \mu_{t,t-1}(r_{f}) = \frac{1}{\Delta t} \log\left(\frac{S_{t}}{S_{t-1}}\right) - r_f\]</p><p>where <span>$S_t$</span> is the volume weighted average price (units: USD/share) at time <code>t</code>, <span>$\Delta t$</span> is the time increment (in years), and <span>$r_f$</span> is the annual risk-free rate (units: 1/years) assuming continuous compounding.</p><p><strong>Arguments</strong></p><ul><li><code>dataset::Dict{String, DataFrame}</code>: A dictionary of data frames where the keys are the firm ticker symbols and the values are the data frames holding price data. We use the <code>volume_weighted_average_price</code> column to compute the log growth by default.</li><li><code>firm::String</code>: The firm ticker symbol for which we want to compute the log growth matrix.</li><li><code>Δt::Float64</code>: The time increment used to compute the log growth. The default value is <code>1/252</code>, i.e., one trading day in units of years.</li><li><code>risk_free_rate::Float64</code>: The risk-free rate used to compute the log growth. The default value is <code>0.0</code>.</li><li><code>keycol::Symbol</code>: The column in the data frame to use to compute the log growth. The default value is <code>:volume_weighted_average_price</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Float64,1}</code>: An array of the excess log growth values for the given firm.</li></ul><p><strong>See:</strong></p><ul><li>The <code>DataFrame</code> type (and methods for working with data frames) is exported from the <a href="https://dataframes.juliadata.org/stable/">DataFrames.jl package</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Base.jl#L57-L82">source</a></section><section><div><pre><code class="language-julia hljs">function log_growth_matrix(dataset::DataFrame; Δt::Float64 = (1.0/252.0), risk_free_rate::Float64 = 0.0,
            keycol::Symbol = :volume_weighted_average_price) -&gt; Array{Float64,1}</code></pre><p>Compute the log growth matrix for a given data frame. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Base.jl#L105-L110">source</a></section><section><div><pre><code class="language-julia hljs">function log_growth_matrix(dataset::Array{Float64,1}, 
            Δt::Float64 = (1.0/252.0), risk_free_rate::Float64 = 0.0)::Array{Float64,1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Base.jl#L131-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.vwap" href="#VLQuantitativeFinancePackage.vwap"><code>VLQuantitativeFinancePackage.vwap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function vwap(data::DataFrame) -&gt; Array{Float64,1}</code></pre><p>The <code>vwap</code> function computes the volume weighted average price (VWAP) for a given data frame.  The VWAP is calculated by multiplying the average price by the volume and then dividing by total volume per period.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: A data frame holding the price data. To compute the VWAP, we use the <code>volume</code> and <code>open</code> and <code>close</code> price fields.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Float64,1}</code>: An array of the VWAP values for the given data frame.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Base.jl#L156-L167">source</a></section></article><h2 id="Lattice-Models"><a class="docs-heading-anchor" href="#Lattice-Models">Lattice Models</a><a id="Lattice-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-Models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.RealWorldBinomialProbabilityMeasure" href="#VLQuantitativeFinancePackage.RealWorldBinomialProbabilityMeasure"><code>VLQuantitativeFinancePackage.RealWorldBinomialProbabilityMeasure</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct RealWorldBinomialProbabilityMeasure &lt;: AbstractProbabilityMeasure</p><p>Immutable type that represents the real-world probability measure.  This type is passed as an argument to various functions to indicate that the real-world probability measure should be used in calculations.   </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Types.jl#L497-L502">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.RiskNeutralBinomialProbabilityMeasure" href="#VLQuantitativeFinancePackage.RiskNeutralBinomialProbabilityMeasure"><code>VLQuantitativeFinancePackage.RiskNeutralBinomialProbabilityMeasure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RiskNeutralBinomialProbabilityMeasure &lt;: AbstractProbabilityMeasure</code></pre><p>Immutable type that represents the risk-neutral probability measure.  This type is passed as an argument to various functions to indicate that the risk-neutral probability measure should be used in calculations.        </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Types.jl#L507-L512">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.MyBinomialEquityPriceTree" href="#VLQuantitativeFinancePackage.MyBinomialEquityPriceTree"><code>VLQuantitativeFinancePackage.MyBinomialEquityPriceTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct MyBinomialEquityPriceTree &lt;: AbstractEquityPriceTreeModel</code></pre><p>This mutable struct represents a binomial lattice model for simulating equity prices. The lattice is constructed using values for the up-factor <code>u</code>, down-factor <code>d</code>, and probability <code>p</code> of an up move computed using either a real-world or risk-neutral probability measure.  A default (largely empty) lattice is created using a build method, and the lattice is populated using the <code>populate</code> function.</p><p><strong>Required fields</strong></p><ul><li><code>u::Float64</code>: The up-factor for the lattice (return for an up move during a single time step)</li><li><code>d::Float64</code>: The down-factor for the lattice (return for a down move during a single time step)</li><li><code>p::Float64</code>: The probability of an up move in the lattice</li></ul><p><strong>Optional or computed fields</strong></p><ul><li><code>μ::Union{Nothing,Float64}</code>: The drift rate of the asset price (needed for option pricing)</li><li><code>T::Union{Nothing,Float64}</code>: The time to expiration of the option contract (needed for option pricing)</li><li><code>connectivity::Union{Nothing, Dict{Int64, Array{Int64,1}}}</code>: A dictionary that holds the connectivity of the lattice where the <code>key</code> is the node index and the <code>value</code> is an array of the connected nodes.</li><li><code>levels::Union{Nothing, Dict{Int64,Array{Int64,1}}}</code>: A dictionary that holds the nodes on each level of the lattice where the <code>key</code> is the level index and the <code>value</code> is an array of the nodes on that level.</li><li><code>ΔT::Union{Nothing,Float64}</code>: The time step size for a single time step in the lattice</li><li><code>data::Union{Nothing, Dict{Int64, MyBiomialLatticeEquityNodeModel}}</code>: A dictionary that holds the lattice data for each node where nodes are modeled as <code>MyBiomialLatticeEquityNodeModel</code> instances.         </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Types.jl#L638-L658">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.build-Tuple{Type{MyBinomialEquityPriceTree}, NamedTuple}" href="#VLQuantitativeFinancePackage.build-Tuple{Type{MyBinomialEquityPriceTree}, NamedTuple}"><code>VLQuantitativeFinancePackage.build</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function build(model::Type{MyBinomialEquityPriceTree}, data::NamedTuple) -&gt; MyBinomialEquityPriceTree</code></pre><p>This <code>build</code> method constructs an instance of the <a href="#VLQuantitativeFinancePackage.MyBinomialEquityPriceTree"><code>MyBinomialEquityPriceTree</code></a> type using the data in a <a href="https://docs.julialang.org/en/v1/base/base/#Core.NamedTuple">NamedTuple</a>.</p><p><strong>Arguments</strong></p><ul><li><code>model::Type{MyBinomialEquityPriceTree}</code>: The type of model to build.</li><li><code>data::NamedTuple</code>: The data to use to build the model.</li></ul><p>The <code>data::NamedTuple</code> must contain the following <code>keys</code>:</p><ul><li><code>u::Float64</code>: The up-factor for the lattice (return for an up move during a single time step)</li><li><code>d::Float64</code>: The down-factor for the lattice (return for a down move during a single time step)</li><li><code>p::Float64</code>: The probability of an up move in the lattice</li></ul><p>The other properties of the <a href="#VLQuantitativeFinancePackage.MyBinomialEquityPriceTree"><code>MyBinomialEquityPriceTree</code></a> model are set to <code>nothing</code> by default and are populated during the construction of the model using the  <code>populate</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Factory.jl#L202-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.populate-Tuple{MyBinomialEquityPriceTree}" href="#VLQuantitativeFinancePackage.populate-Tuple{MyBinomialEquityPriceTree}"><code>VLQuantitativeFinancePackage.populate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function populate(model::MyBinomialEquityPriceTree; 
            Sₒ::Float64 = 100.0, h::Int = 1) -&gt; MyBinomialEquityPriceTree</code></pre><p>The <code>populate</code> function initializes a <a href="#VLQuantitativeFinancePackage.MyBinomialEquityPriceTree"><code>MyBinomialEquityPriceTree</code></a> model with share prices and probabilities for each node in a lattice of height <code>h</code>.</p><p><strong>Arguments</strong></p><ul><li><code>model::MyBinomialEquityPriceTree</code>: An instance of the <a href="#VLQuantitativeFinancePackage.MyBinomialEquityPriceTree"><code>MyBinomialEquityPriceTree</code></a> type constructed using the corresponding <code>build</code> function.</li><li><code>Sₒ::Float64 = 100.0</code>: The initial price of the equity at time <code>0</code>. Default value is <code>100.0</code> dollars per share.</li><li><code>h::Int = 1</code>: The height of the binomial price tree. Default value is <code>1</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>MyBinomialEquityPriceTree</code>: An updated instance of the <a href="#VLQuantitativeFinancePackage.MyBinomialEquityPriceTree"><code>MyBinomialEquityPriceTree</code></a> type with the share prices and probabilities computed for each node in the lattice. </li></ul><p>Node data is stored in the <code>data</code> field of the model (as MyBiomialLatticeEquityNodeModel instances), and the connectivity of the lattice is stored in the <code>connectivity</code> field. See the <a href="#VLQuantitativeFinancePackage.MyBinomialEquityPriceTree"><code>MyBinomialEquityPriceTree</code></a> type for more information on the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Compute.jl#L1163-L1179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.sample-Tuple{MyBinomialEquityPriceTree, Int64}" href="#VLQuantitativeFinancePackage.sample-Tuple{MyBinomialEquityPriceTree, Int64}"><code>VLQuantitativeFinancePackage.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function sample(model::MyBinomialEquityPriceTree, L::Int64; number_of_paths::Int64 = 100) -&gt; Array{Float64,2}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Compute.jl#L1239-L1241">source</a></section></article><h3 id="Short-cut-syntax-for-data-driven-binomial-trees"><a class="docs-heading-anchor" href="#Short-cut-syntax-for-data-driven-binomial-trees">Short cut syntax for data-driven binomial trees</a><a id="Short-cut-syntax-for-data-driven-binomial-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Short-cut-syntax-for-data-driven-binomial-trees" title="Permalink"></a></h3><p>We provide a short-cut syntax to estimate the values of the <span>$(u, d, p)$</span> parameters of a binomial tree model using historical data. The short-cut syntax allows the user to specify a probability measure, the time step in the data, and the historical growth rate data required to estimate the parameters.</p><p>For example, to estimate the expected <span>$(\bar{u}, \bar{d}, \bar{p})$</span> parameters of using historical growth data for a single-asset with time-step <span>$\Delta{t}$</span> assuming a real-world probability measure, the user can use the following code:</p><pre><code class="language-julia hljs">(ū,d̄,p̄) = (RealWorldBinomialProbabilityMeasure())(growth_rate_array; Δt = Δt);</code></pre><h2 id="Geometric-Brownian-Motion"><a class="docs-heading-anchor" href="#Geometric-Brownian-Motion">Geometric Brownian Motion</a><a id="Geometric-Brownian-Motion-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-Brownian-Motion" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.MyGeometricBrownianMotionEquityModel" href="#VLQuantitativeFinancePackage.MyGeometricBrownianMotionEquityModel"><code>VLQuantitativeFinancePackage.MyGeometricBrownianMotionEquityModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct MyGeometricBrownianMotionEquityModel &lt;: AbstractAssetModel</code></pre><p>The <code>MyGeometricBrownianMotionEquityModel</code> mutable struct represents a <a href="https://en.wikipedia.org/wiki/Geometric_Brownian_motion">geometric Brownian motion</a> model for  a single equity asset.</p><p><strong>Fields</strong></p><ul><li><code>μ::Float64</code>: The drift rate of the asset price</li><li><code>σ::Float64</code>: The volatility of the asset price</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Types.jl#L130-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.MyMultipleAssetGeometricBrownianMotionEquityModel" href="#VLQuantitativeFinancePackage.MyMultipleAssetGeometricBrownianMotionEquityModel"><code>VLQuantitativeFinancePackage.MyMultipleAssetGeometricBrownianMotionEquityModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct MyMultipleAssetGeometricBrownianMotionEquityModel &lt;: AbstractAssetModel</code></pre><p>The <code>MyMultipleAssetGeometricBrownianMotionEquityModel</code> mutable struct represents a <a href="https://en.wikipedia.org/wiki/Geometric_Brownian_motion">geometric Brownian motion</a> model for multiple equity assets. </p><p><strong>Fields</strong></p><ul><li><code>μ::Array{Float64,1}</code>: The drift rates of the asset prices</li><li><code>A::Array{Float64,2}</code>: The <a href="https://en.wikipedia.org/wiki/Cholesky_decomposition">Cholesky decomposition</a> of the covariance matrix between the asset returns.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Types.jl#L150-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.build-Tuple{Type{MyGeometricBrownianMotionEquityModel}, NamedTuple}" href="#VLQuantitativeFinancePackage.build-Tuple{Type{MyGeometricBrownianMotionEquityModel}, NamedTuple}"><code>VLQuantitativeFinancePackage.build</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function build(model::Type{MyGeometricBrownianMotionEquityModel}, data::NamedTuple) -&gt; MyGeometricBrownianMotionEquityModel</code></pre><p>This <code>build</code> method constructs an instance of the <a href="#VLQuantitativeFinancePackage.MyGeometricBrownianMotionEquityModel"><code>MyGeometricBrownianMotionEquityModel</code></a> type using the data in a <a href="https://docs.julialang.org/en/v1/base/base/#Core.NamedTuple">NamedTuple</a>.</p><p><strong>Arguments</strong></p><ul><li><code>model::Type{MyGeometricBrownianMotionEquityModel}</code>: The type of model to build.</li><li><code>data::NamedTuple</code>: The data to use to build the model.</li></ul><p>The <code>data::NamedTuple</code> must contain the following <code>keys</code>:</p><ul><li><code>μ::Float64</code>: The drift of the process.</li><li><code>σ::Float64</code>: The volatility of the process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Factory.jl#L365-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.build-Tuple{Type{MyMultipleAssetGeometricBrownianMotionEquityModel}, NamedTuple}" href="#VLQuantitativeFinancePackage.build-Tuple{Type{MyMultipleAssetGeometricBrownianMotionEquityModel}, NamedTuple}"><code>VLQuantitativeFinancePackage.build</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function build(model::Type{MyMultipleAssetGeometricBrownianMotionEquityModel}, data::NamedTuple) -&gt; MyMultipleAssetGeometricBrownianMotionEquityModel</code></pre><p>This <code>build</code> method constructs an instance of the <a href="#VLQuantitativeFinancePackage.MyMultipleAssetGeometricBrownianMotionEquityModel"><code>MyMultipleAssetGeometricBrownianMotionEquityModel</code></a> type using the data in a <a href="https://docs.julialang.org/en/v1/base/base/#Core.NamedTuple">NamedTuple</a>.</p><p><strong>Arguments</strong></p><ul><li><code>model::Type{MyMultipleAssetGeometricBrownianMotionEquityModel}</code>: The type of model to build.</li><li><code>data::NamedTuple</code>: The data to use to build the model.</li></ul><p>The <code>data::NamedTuple</code> must contain the following <code>keys</code>:</p><ul><li><code>μ::Array{Float64,1}</code>: Array of drift rates for each asset.</li><li><code>A::Array{Float64,2}</code>: <a href="https://en.wikipedia.org/wiki/Cholesky_decomposition">Cholesky decomposition</a> of the covariance matrix of the process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Factory.jl#L380-L392">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.sample-Tuple{MyGeometricBrownianMotionEquityModel, NamedTuple}" href="#VLQuantitativeFinancePackage.sample-Tuple{MyGeometricBrownianMotionEquityModel, NamedTuple}"><code>VLQuantitativeFinancePackage.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample(model::MyGeometricBrownianMotionEquityModel, data::NamedTuple; 
    number_of_paths::Int64 = 100) -&gt; Array{Float64,2}</code></pre><p>The <code>sample</code> function simulates the geometric Brownian motion model for a single equity using the analytical solution. The model is defined by the parameters <code>μ</code> and <code>σ</code> which are the drift and volatility of the equity return, respectively. The simulation is performed over a time interval <code>T</code> and the initial price of the equity is <code>Sₒ</code>.  The function returns a matrix of size <code>(number_of_time_steps, number_of_paths + 1)</code> where each row represents a single path of the equity price over time.</p><p><strong>Arguments</strong></p><ul><li><code>model::MyGeometricBrownianMotionEquityModel</code>: An instance of the <a href="#VLQuantitativeFinancePackage.MyGeometricBrownianMotionEquityModel">MyGeometricBrownianMotionEquityModel</a> type which models the geometric Brownian motion for the equity.</li><li><code>data::NamedTuple</code>: A named tuple that contains the data for the simulation. </li></ul><p>The <code>data::NamedTuple</code> must contain the following keys:</p><ul><li><code>T₁::Float64</code>: The start time of the simulation.</li><li><code>T₂::Float64</code>: The end time of the simulation.</li><li><code>Δt::Float64</code>: The time increment for the simulation.</li><li><code>Sₒ::Float64</code>: The initial price of the equity.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Float64,2}</code>: A matrix of size <code>(number_of_time_steps, number_of_paths + 1)</code> where each row represents a single path of the equity price over time. The first column contains the time values.</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>number_of_paths::Int64 = 100</code>: The number of paths to simulate. Default value is <code>100</code> paths.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Compute.jl#L587-L611">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.sample-Tuple{MyMultipleAssetGeometricBrownianMotionEquityModel, NamedTuple}" href="#VLQuantitativeFinancePackage.sample-Tuple{MyMultipleAssetGeometricBrownianMotionEquityModel, NamedTuple}"><code>VLQuantitativeFinancePackage.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample(model::MyMultipleAssetGeometricBrownianMotionEquityModel, data::NamedTuple; 
    number_of_paths::Int64 = 100) -&gt; Dict{Int64, Array{Float64,2}}</code></pre><p>The <code>sample</code> function simulates the geometric Brownian motion model for multiple equities using the analytical solution.</p><p><strong>Arguments</strong></p><ul><li><code>model::MyMultipleAssetGeometricBrownianMotionEquityModel</code>: An instance of the <a href="#VLQuantitativeFinancePackage.MyMultipleAssetGeometricBrownianMotionEquityModel">MyMultipleAssetGeometricBrownianMotionEquityModel</a> type which models the geometric Brownian motion for multiple equities.</li><li><code>data::NamedTuple</code>: A named tuple that contains the data for the simulation.</li></ul><p>The <code>data::NamedTuple</code> must contain the following keys:</p><ul><li><code>T₁::Float64</code>: The start time of the simulation.</li><li><code>T₂::Float64</code>: The end time of the simulation.</li><li><code>Δt::Float64</code>: The time increment for the simulation.</li><li><code>Sₒ::Array{Float64,1}</code>: The initial prices of the equities.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Int64, Array{Float64,2}}</code>: A dictionary of simulations where the <code>key</code> is the path index and the <code>value</code> is a matrix of size <code>(number_of_time_steps, number_of_assets + 1)</code> where each row represents a time step, and columns represents an asset price. The first column contains the time values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Compute.jl#L655-L673">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.sample_endpoint-Tuple{MyGeometricBrownianMotionEquityModel, NamedTuple}" href="#VLQuantitativeFinancePackage.sample_endpoint-Tuple{MyGeometricBrownianMotionEquityModel, NamedTuple}"><code>VLQuantitativeFinancePackage.sample_endpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_endpoint(model::MyGeometricBrownianMotionEquityModel, data::NamedTuple; 
    number_of_paths::Int64 = 100) -&gt; Array{Float64,1}</code></pre><p>The <code>sample_endpoint</code> function simulates the geometric Brownian motion model for a single equity using the analytical solution at time <code>T</code>.</p><p><strong>Arguments</strong></p><ul><li><code>model::MyGeometricBrownianMotionEquityModel</code>: An instance of the <a href="#VLQuantitativeFinancePackage.MyGeometricBrownianMotionEquityModel">MyGeometricBrownianMotionEquityModel</a> type which models the geometric Brownian motion for the equity.</li><li><code>data::NamedTuple</code>: A named tuple that contains the data for the simulation.</li></ul><p>The <code>data::NamedTuple</code> must contain the following keys:</p><ul><li><code>T::Float64</code>: The time at which to sample the equity price.</li><li><code>Sₒ::Float64</code>: The initial price of the equity at time <code>0</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Float64,1}</code>: An array of size <code>number_of_paths</code> that contains the equity price at time <code>T</code>.</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>number_of_paths::Int64 = 100</code>: The number of paths to simulate. Default value is <code>100</code> paths.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Compute.jl#L540-L559">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.expectation-Tuple{MyGeometricBrownianMotionEquityModel, NamedTuple}" href="#VLQuantitativeFinancePackage.expectation-Tuple{MyGeometricBrownianMotionEquityModel, NamedTuple}"><code>VLQuantitativeFinancePackage.expectation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function expectation(model::MyGeometricBrownianMotionEquityModel, data::NamedTuple) -&gt; Array{Float64,2}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Compute.jl#L459-L461">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.variance-Tuple{MyGeometricBrownianMotionEquityModel, NamedTuple}" href="#VLQuantitativeFinancePackage.variance-Tuple{MyGeometricBrownianMotionEquityModel, NamedTuple}"><code>VLQuantitativeFinancePackage.variance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function variance(model::MyGeometricBrownianMotionEquityModel, data::NamedTuple) -&gt; Array{Float64,2}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Compute.jl#L498-L500">source</a></section></article><h2 id="Advanced-Stochastic-Pricing-and-Return-Models"><a class="docs-heading-anchor" href="#Advanced-Stochastic-Pricing-and-Return-Models">Advanced Stochastic Pricing and Return Models</a><a id="Advanced-Stochastic-Pricing-and-Return-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Stochastic-Pricing-and-Return-Models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.EulerMaruyamaMethod" href="#VLQuantitativeFinancePackage.EulerMaruyamaMethod"><code>VLQuantitativeFinancePackage.EulerMaruyamaMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct EulerMaruyamaMethod &lt;: AbstractStochasticSolverModel</code></pre><p>Immutable type that represents the <a href="https://en.wikipedia.org/wiki/Euler–Maruyama_method">Euler-Maruyama method</a> for solving stochastic differential equations. This type is passed to various functions in their <code>method</code> argument to indicate that the <a href="https://en.wikipedia.org/wiki/Euler–Maruyama_method">Euler-Maruyama method</a>  should be used in calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Types.jl#L251-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.MyOrnsteinUhlenbeckModel" href="#VLQuantitativeFinancePackage.MyOrnsteinUhlenbeckModel"><code>VLQuantitativeFinancePackage.MyOrnsteinUhlenbeckModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct MyOrnsteinUhlenbeckModel &lt;: AbstractAssetModel</code></pre><p>A mutable struct that represents a <a href="https://en.wikipedia.org/wiki/Ornstein–Uhlenbeck_process">Ornstein-Uhlenbeck process</a>. An instance of <code>MyOrnsteinUhlenbeckModel</code> is configured and constructed using a corresponding <code>build</code> method.</p><p><strong>Fields</strong></p><ul><li><code>μ::Function</code>: The price drift function (long term price level)</li><li><code>σ::Function</code>: The price volatility function</li><li><code>θ::Function</code>: The mean reversion function. This function determines how quickly the price reverts to the long-term mean.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Types.jl#L172-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.MyHestonModel" href="#VLQuantitativeFinancePackage.MyHestonModel"><code>VLQuantitativeFinancePackage.MyHestonModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct MyHestonModel &lt;: AbstractAssetModel</code></pre><p>A mutable struct that represents the <a href="https://en.wikipedia.org/wiki/Heston_model">Heston model</a>.  An instance of <code>MyHestonModel</code> is configured and constructed using a corresponding <code>build</code> method.</p><p><strong>Fields</strong></p><ul><li><code>μ::Function</code>: Drift function takes the state matrix <code>X</code> and time <code>t</code> and returns a scalar, i.e., <span>$\mu:X\times{t}\rightarrow\mathbb{R}$</span></li><li><code>κ::Function</code>: Mean reversion function</li><li><code>θ::Function</code>: Long-run volatility function</li><li><code>ξ::Function</code>: Volatility of volatility function</li><li><code>Σ::Array{Float64,2}</code>: Covariance matrix between the asset price and the volatility process</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Types.jl#L195-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.build-Tuple{Type{MyOrnsteinUhlenbeckModel}, NamedTuple}" href="#VLQuantitativeFinancePackage.build-Tuple{Type{MyOrnsteinUhlenbeckModel}, NamedTuple}"><code>VLQuantitativeFinancePackage.build</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function build(modeltype::Type{MyOrnsteinUhlenbeckModel}, data::NamedTuple) -&gt; MyOrnsteinUhlenbeckModel</code></pre><p>This method builds an instance of the <a href="#VLQuantitativeFinancePackage.MyOrnsteinUhlenbeckModel"><code>MyOrnsteinUhlenbeckModel</code></a> type using the data in a <a href="https://docs.julialang.org/en/v1/base/base/#Core.NamedTuple">NamedTuple</a>.</p><p><strong>Arguments</strong></p><ul><li><code>modeltype::Type{MyOrnsteinUhlenbeckModel}</code>: The type of model to build.</li><li><code>data::NamedTuple</code>: The data to use to build the model. </li></ul><p>The <code>data::NamedTuple</code> argument must contain the following <code>keys</code>:</p><ul><li><code>μ::Float64</code>: The long-term mean of the process.</li><li><code>σ::Float64</code>: The volatility of the process.</li><li><code>θ::Float64</code>: The mean reversion rate of the process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Factory.jl#L472-L485">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.build-Tuple{Type{MyHestonModel}, NamedTuple}" href="#VLQuantitativeFinancePackage.build-Tuple{Type{MyHestonModel}, NamedTuple}"><code>VLQuantitativeFinancePackage.build</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function build(model::Type{MyHestonModel}, data::NamedTuple) -&gt; MyHestonModel</code></pre><p>This <code>build</code> method constructs an instance of the <a href="#VLQuantitativeFinancePackage.MyHestonModel"><code>MyHestonModel</code></a> type using the data in a <a href="https://docs.julialang.org/en/v1/base/base/#Core.NamedTuple">NamedTuple</a>.</p><p><strong>Arguments</strong></p><ul><li><code>model::Type{MyHestonModel}</code>: The type of model to build.</li><li><code>data::NamedTuple</code>: The data to use to build the model. </li></ul><p>The <code>data::NamedTuple</code> must contain the following <code>keys</code>:</p><ul><li><code>μ::Function</code>: The long-term mean of the process.</li><li><code>κ::Function</code>: The mean reversion rate of the process.</li><li><code>θ::Function</code>: The volatility of the process.</li><li><code>ξ::Function</code>: The volatility of the volatility of the process.</li><li><code>Σ::Array{Float64,2}</code>: The covariance matrix of the process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Factory.jl#L396-L411">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.solve-Tuple{AbstractAssetModel, NamedTuple, AbstractArray}" href="#VLQuantitativeFinancePackage.solve-Tuple{AbstractAssetModel, NamedTuple, AbstractArray}"><code>VLQuantitativeFinancePackage.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function solve(model::AbstractAssetModel, tspan::NamedTuple, initialconditions::AbstractArray; 
            method::AbstractStochasticSolverModel = EulerMaruyamaMethod(), N::Int64 = 100)::Tuple</code></pre><p>The <code>solve</code> function is used to solve a stochastic asset model.  The function takes a model, time span, initial conditions, method, and number of paths as input and returns a tuple of time and state arrays.  The <code>method</code> argument is used to specify the method used to solve the model. The <code>N</code> argument is used to specify the number of paths to simulate.  The function uses the Euler-Maruyama method as the default method to solve the model.</p><p><strong>Arguments</strong></p><ul><li><code>model::AbstractAssetModel</code>: The asset model to solve.</li><li><code>tspan::NamedTuple</code>: The time span to solve the model over. The NamedTuple should have the fields <code>start</code>, <code>stop</code>, and <code>step</code>.</li><li><code>initialconditions::AbstractArray</code>: The initial conditions for the model.</li><li><code>method::AbstractStochasticSolverModel = EulerMaruyamaMethod()</code>: The method used to solve the model. Default is <a href="https://en.wikipedia.org/wiki/Euler–Maruyama_method">Euler-Maruyama</a>.</li><li><code>N::Int64 = 100</code>: The number of paths to simulate. Default is 100 paths.</li></ul><p><strong>Return</strong></p><ul><li><code>Tuple</code>: A tuple of time and state arrays (more than one with multidimensional models) where the rows are the time steps and the columns are the paths. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/EulerMaruyamaMethod.jl#L93-L111">source</a></section></article><h2 id="Structured-State-Space-Models"><a class="docs-heading-anchor" href="#Structured-State-Space-Models">Structured State-Space Models</a><a id="Structured-State-Space-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Structured-State-Space-Models" title="Permalink"></a></h2><p>Update this section with some groooovy text.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.MySisoLegSHippoModel" href="#VLQuantitativeFinancePackage.MySisoLegSHippoModel"><code>VLQuantitativeFinancePackage.MySisoLegSHippoModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct MySisoLegSHippoModel &lt;: AbstractAssetModel</code></pre><p>A mutable struct that represents a single-input, single-output (SISO) linear time-invariant (LTI) system that used the Leg-S parameterization. An instance of <code>MySisoLegSHippoModel</code> is configuired and constructed using a corresponding <code>build</code> method.</p><p><strong>Fields</strong></p><ul><li><code>Â::Array{Float64,2}</code>: Discretized state matrix of the system <code>Â ∈ ℝ^(n x n)</code> where <code>n</code> is the number of hidden states</li><li><code>B̂::Array{Float64,1}</code>: Discretized input matrix of the system <code>B̂ ∈ ℝ^n x 1</code></li><li><code>Ĉ::Array{Float64,1}</code>: Discretized output matrix of the system <code>Ĉ ∈ ℝ^1 x n</code></li><li><code>D̂::Array{Float64,1}</code>: Discretized feedforward matrix of the system <code>D̂ ∈ ℝ^1 x 1</code></li><li><code>n::Int</code>: Number of hidden states in the system</li><li><code>Xₒ::Array{Float64,1}</code>: Initial conditions of the system</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Types.jl#L221-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.build-Tuple{Type{MySisoLegSHippoModel}, NamedTuple}" href="#VLQuantitativeFinancePackage.build-Tuple{Type{MySisoLegSHippoModel}, NamedTuple}"><code>VLQuantitativeFinancePackage.build</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function build(modeltype::Type{MySisoLegSHippoModel}, data::NamedTuple) -&gt; MySisoLegSHippoModel</code></pre><p>This <code>build</code> method constructs an instance of the <a href="#VLQuantitativeFinancePackage.MySisoLegSHippoModel"><code>MySisoLegSHippoModel</code></a> type using the data in a <a href="https://docs.julialang.org/en/v1/base/base/#Core.NamedTuple">NamedTuple</a>. This implementation uses the bilinear method to discretize the model, where the <code>A</code> and <code>B</code> matrices are computed using the <a href="https://arxiv.org/abs/2008.07669">Leg-S parameterization</a>.</p><p><strong>Arguments</strong></p><ul><li><code>modeltype::Type{MySisoLegSHippoModel}</code>: The type of model to build.</li><li><code>data::NamedTuple</code>: The data to use to build the model. </li></ul><p>The <code>data::NamedTuple</code> must contain the following <code>keys</code>:</p><ul><li><code>number_of_hidden_states::Int64</code>: The number of hidden states in the model.</li><li><code>Δt::Float64</code>: The time step size used to discretize the model (constant).</li><li><code>uₒ::Array{Float64,1}</code>: The initial input to the model.</li><li><code>C::Array{Float64,1}</code>: The output matrix of the model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Factory.jl#L499-L515">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.solve-Tuple{MySisoLegSHippoModel, NamedTuple, Array{Float64}}" href="#VLQuantitativeFinancePackage.solve-Tuple{MySisoLegSHippoModel, NamedTuple, Array{Float64}}"><code>VLQuantitativeFinancePackage.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function solve(model::MySisoLegSHippoModel, tspan::NamedTuple, signal::Array{Float64}) -&gt; Tuple</code></pre><p>The <code>solve</code> function solves the single input single output (SISO) HiPPO model using the Leg-S parameterization and  bilinear discretization. The function returns the time array, the hidden state array and the output array.</p><p><strong>Arguments</strong></p><ul><li><code>model::MySisoLegSHippoModel</code>: A model struct that defines the HiPPO model, see <a href="#VLQuantitativeFinancePackage.MySisoLegSHippoModel">MySisoLegSHippoModel</a> for details on the model struct.</li><li><code>tspan::NamedTuple</code>: A named tuple that defines the time span for the simulation. The named tuple should have the fields <code>start</code>, <code>stop</code> and <code>step</code>.</li><li><code>signal::Array{Float64}</code>: An array of input signals to the model.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple</code>: A tuple of the time array <code>T</code>, hidden state array <code>X</code> and the output array <code>Y</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Hippo.jl#L90-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.prediction-Tuple{MySisoLegSHippoModel, NamedTuple, Vector{Float64}}" href="#VLQuantitativeFinancePackage.prediction-Tuple{MySisoLegSHippoModel, NamedTuple, Vector{Float64}}"><code>VLQuantitativeFinancePackage.prediction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function prediction(model::MySisoLegSHippoModel, tspan::NamedTuple, signal::Array{Float64,1}; L::Int64 = 10) -&gt; Tuple</code></pre><p>The <code>prediction</code> function predicts the output of the single input single output (SISO) HiPPO model given a signal vector using the Leg-S parameterization and bilinear discretization.  The function returns the time array, the hidden state array and the output array. </p><p><strong>Arguments</strong></p><ul><li><code>model::MySisoLegSHippoModel</code>: A model struct that defines the HiPPO model, see <a href="#VLQuantitativeFinancePackage.MySisoLegSHippoModel">MySisoLegSHippoModel</a> for details on the model struct.</li><li><code>tspan::NamedTuple</code>: A named tuple that defines the time span for the simulation. The named tuple should have the fields <code>start</code>, <code>stop</code> and <code>step</code>.</li><li><code>signal::Array{Float64}</code>: An array of input signals to the model.</li><li><code>S::Int64</code>: Circular buffer size used by the prediction function. The default value is 10 steps. After <code>L</code> steps, the input signal is reset to the first signal value.</li><li><code>B::Float64</code>: A threshold value used to reset the hidden states. The default value is 40.0.</li><li><code>α::Float64</code>: A scaling factor used to check the output value. The default value is 0.25.</li><li><code>β::Float64</code>: A scaling factor used to reset the hidden states. The default value is 0.10.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple</code>: A tuple of the time array <code>T</code>, hidden state array <code>X</code> and the output array <code>Y</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Hippo.jl#L20-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VLQuantitativeFinancePackage.estimate_hippo_parameters-Tuple{MySisoLegSHippoModel, NamedTuple, Array{Float64}}" href="#VLQuantitativeFinancePackage.estimate_hippo_parameters-Tuple{MySisoLegSHippoModel, NamedTuple, Array{Float64}}"><code>VLQuantitativeFinancePackage.estimate_hippo_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function estimate_hippo_parameters(model::MySisoLegSHippoModel, tspan::NamedTuple, signal::Array{Float64};
    method = LBFGS()) -&gt; Array{Float64}</code></pre><p>The <code>estimate_hippo_parameters</code> function estimates the <code>C</code>-matrix of the single input single output (SISO)  Leg-S bilinear discretized HiPPO model. The <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl package</a> is used to minimize the <a href="https://en.wikipedia.org/wiki/Loss_function">squared error loss between the estimated and observed model output</a>. The function returns the estimated parameters.</p><p><strong>Arguments</strong></p><ul><li><code>model::MySisoLegSHippoModel</code>: A model struct that defines the HiPPO model, see <a href="#VLQuantitativeFinancePackage.MySisoLegSHippoModel">MySisoLegSHippoModel</a> for details on the model struct.</li><li><code>tspan::NamedTuple</code>: A named tuple that defines the time span for the simulation. The named tuple should have the fields <code>start</code>, <code>stop</code> and <code>step</code>.</li><li><code>signal::Array{Float64}</code>: An array of input signals to the model.</li><li><code>method::AbstractOptimizer</code>: An optimizer to use for the optimization problem. The default optimizer is the <a href="https://julianlsolvers.github.io/Optim.jl/stable/algo/lbfgs/">LBFGS routine of the Optim.jl</a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Float64}</code>: An array of estimated parameters for the <code>C</code>-matrix of the HiPPO model</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/varnerlab/VLQuantitativeFinancePackage.jl/blob/1aca7c2b6cd10a4fac866485b685a782acee603d/src/Hippo.jl#L139-L155">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fixed/">« Treasury securities</a><a class="docs-footer-nextpage" href="../derivatives/">Derivative securities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Tuesday 13 August 2024 11:39">Tuesday 13 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

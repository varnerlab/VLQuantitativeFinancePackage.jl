var documenterSearchIndex = {"docs":
[{"location":"derivatives/#Derivative-Securities","page":"Derivatives","title":"Derivative Securities","text":"","category":"section"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"Fill me in","category":"page"},{"location":"equity/#Equity-Securities","page":"Equity","title":"Equity Securities","text":"","category":"section"},{"location":"equity/","page":"Equity","title":"Equity","text":"This should update now.","category":"page"},{"location":"equity/","page":"Equity","title":"Equity","text":"VLQuantitativeFinancePackage.EulerMaruyamaMethod\nVLQuantitativeFinancePackage.MyOrnsteinUhlenbeckModel\nVLQuantitativeFinancePackage.MySisoLegSHippoModel\nVLQuantitativeFinancePackage.MyHestonModel\nVLQuantitativeFinancePackage.solve","category":"page"},{"location":"equity/#VLQuantitativeFinancePackage.EulerMaruyamaMethod","page":"Equity","title":"VLQuantitativeFinancePackage.EulerMaruyamaMethod","text":"struct EulerMaruyamaMethod <: AbstractStochasticSolverModel\n\nImmutable type that represents the Euler-Maruyama method for solving stochastic differential equations. This type is passed to various functions in their method argument to indicate that the Euler-Maruyama method  should be used in calculations.\n\n\n\n\n\n","category":"type"},{"location":"equity/#VLQuantitativeFinancePackage.MyOrnsteinUhlenbeckModel","page":"Equity","title":"VLQuantitativeFinancePackage.MyOrnsteinUhlenbeckModel","text":"mutable struct MyOrnsteinUhlenbeckModel <: AbstractAssetModel\n\nA mutable struct that represents a Ornstein-Uhlenbeck process. An instance of MyOrnsteinUhlenbeckModel is configured and constructed using a corresponding build method.\n\nFields\n\nμ::Function: The price drift function (long term price level)\nσ::Function: The price volatility function\nθ::Function: The mean reversion function. This function determines how quickly the price reverts to the long-term mean.\n\n\n\n\n\n","category":"type"},{"location":"equity/#VLQuantitativeFinancePackage.MySisoLegSHippoModel","page":"Equity","title":"VLQuantitativeFinancePackage.MySisoLegSHippoModel","text":"mutable struct MySisoLegSHippoModel <: AbstractAssetModel\n\nA mutable struct that represents a single-input, single-output (SISO) linear time-invariant (LTI) system that used the Leg-S parameterization. An instance of MySisoLegSHippoModel is configuired and constructed using a corresponding build method.\n\nFields\n\nÂ::Array{Float64,2}: Discretized state matrix of the system Â ∈ ℝ^(n x n) where n is the number of hidden states\nB̂::Array{Float64,1}: Discretized input matrix of the system B̂ ∈ ℝ^n x 1\nĈ::Array{Float64,1}: Discretized output matrix of the system Ĉ ∈ ℝ^1 x n\nD̂::Array{Float64,1}: Discretized feedforward matrix of the system D̂ ∈ ℝ^1 x 1\nn::Int: Number of hidden states in the system\nXₒ::Array{Float64,1}: Initial conditions of the system\n\n\n\n\n\n","category":"type"},{"location":"equity/#VLQuantitativeFinancePackage.MyHestonModel","page":"Equity","title":"VLQuantitativeFinancePackage.MyHestonModel","text":"mutable struct MyHestonModel <: AbstractAssetModel\n\nA mutable struct that represents the Heston model.  An instance of MyHestonModel is configured and constructed using a corresponding build method.\n\nFields\n\nμ::Function: Drift function\nκ::Function: Mean reversion function\nθ::Function: Long-run volatility function\nξ::Function: Volatility of volatility function\nΣ::Array{Float64,2}: Covariance matrix between the asset price and the volatility process\n\n\n\n\n\n","category":"type"},{"location":"equity/#VLQuantitativeFinancePackage.solve","page":"Equity","title":"VLQuantitativeFinancePackage.solve","text":"solve(model::AbstractAssetModel, tspan::NamedTuple, initialconditions::AbstractArray; \n    method::AbstractStochasticSolverModel = EulerMaruyamaMethod(), N::Int64 = 100)::Tuple\n\nThe solve function is used to solve a stochastic asset model.  The function takes a model, time span, initial conditions, method, and number of paths as input and returns a tuple of time and state arrays.  The method argument is used to specify the method used to solve the model. The N argument is used to specify the number of paths to simulate.  The function uses the Euler-Maruyama method as the default method to solve the model.\n\nArguments\n\nmodel::AbstractAssetModel: The asset model to solve.\ntspan::NamedTuple: The time span to solve the model over. The NamedTuple should have the fields start, stop, and step.\ninitialconditions::AbstractArray: The initial conditions for the model.\nmethod::AbstractStochasticSolverModel = EulerMaruyamaMethod(): The method used to solve the model. Default is Euler-Maruyama.\nN::Int64 = 100: The number of paths to simulate. Default is 100 paths.\n\nReturn\n\nTuple: A tuple of time and state arrays (more than one with multidimensional models) where the rows are the time steps and the columns are the paths. \n\n\n\n\n\n","category":"function"},{"location":"factory/#Factory","page":"Factory","title":"Factory","text":"","category":"section"},{"location":"factory/","page":"Factory","title":"Factory","text":"We provide a factory function build to construct most of the types used in this package.","category":"page"},{"location":"factory/","page":"Factory","title":"Factory","text":"VLQuantitativeFinancePackage.build","category":"page"},{"location":"factory/#VLQuantitativeFinancePackage.build","page":"Factory","title":"VLQuantitativeFinancePackage.build","text":"build(model::Type{MyUSTreasuryZeroCouponBondModel}, data::NamedTuple) -> MyUSTreasuryZeroCouponBondModel\n\nThis build method constructs an instance of the MyUSTreasuryZeroCouponBondModel type using the data in the NamedTuple.\n\nArguments\n\nmodel::Type{MyUSTreasuryZeroCouponBondModel}: The type of model to build.\ndata::NamedTuple: The data to use to build the model. The data must contain the following keys\n\nThe data NamedTuple must contain the following keys\n\npar::Float64: The face or par value of the bond\nrate::Union{Nothing, Float64}: Effective annual interest rate (discount rate specified as a decimal)\nT::Union{Nothing,Float64}: Duration in years of the instrument, measured as a 365 day or a 52 week year\nn::Int: Number of compounding periods per year (typically 2)\n\n\n\n\n\nbuild(modeltype::Type{MyOrnsteinUhlenbeckModel}, data::NamedTuple) -> MyOrnsteinUhlenbeckModel\n\nThis method builds an instance of the MyOrnsteinUhlenbeckModel type using the data in the NamedTuple.\n\nArguments\n\nmodeltype::Type{MyOrnsteinUhlenbeckModel}: The type of model to build.\ndata::NamedTuple: The data to use to build the model. The data must contain the following keys\nμ::Float64: The long-term mean of the process.\nσ::Float64: The volatility of the process.\nθ::Float64: The mean reversion rate of the process.\n\n\n\n\n\nbuild(modeltype::Type{MySisoLegSHippoModel}, data::NamedTuple) -> MySisoLegSHippoModel\n\nThis build method constructs an instance of the MySisoLegSHippoModel type using the data in the NamedTuple. This implementation uses the bilinear method to discretize the model, where the A and B matrices are computed using the Leg-S parameterization.\n\nArguments\n\nmodeltype::Type{MySisoLegSHippoModel}: The type of model to build.\ndata::NamedTuple: The data to use to build the model. The data must contain the following keys\nnumber_of_hidden_states::Int64: The number of hidden states in the model.\nΔt::Float64: The time step size used to discretize the model (constant)\nuₒ::Array{Float64,1}: The initial input to the model.\nC::Array{Float64,1}: The output matrix of the model.\n\n\n\n\n\n","category":"function"},{"location":"fixed/#Fixed-Income-Securities","page":"Fixed Income","title":"Fixed Income Securities","text":"","category":"section"},{"location":"fixed/","page":"Fixed Income","title":"Fixed Income","text":"Fixed income securities are financial instruments that pay a fixed amount of interest over a specified period of time. The most common fixed income securities are bonds, which are issued by governments, municipalities, and corporations. The fixed income market is one of the largest financial markets in the world, and it plays a critical role in the global economy.","category":"page"},{"location":"fixed/#Discounting-models","page":"Fixed Income","title":"Discounting models","text":"","category":"section"},{"location":"fixed/","page":"Fixed Income","title":"Fixed Income","text":"In the VLQuantitativeFinancePackage we allow computing the present value of a cash flow stream using a discounting model.  The present value of a cash flow stream can be computed using a ContinuousDiscountingModel or a DiscreteDiscountingModel.","category":"page"},{"location":"fixed/","page":"Fixed Income","title":"Fixed Income","text":"VLQuantitativeFinancePackage.DiscreteCompoundingModel\nVLQuantitativeFinancePackage.ContinuousCompoundingModel","category":"page"},{"location":"fixed/#VLQuantitativeFinancePackage.DiscreteCompoundingModel","page":"Fixed Income","title":"VLQuantitativeFinancePackage.DiscreteCompoundingModel","text":"struct DiscreteCompoundingModel <: AbstractCompoundingModel\n\nImmutable type that represents discrete compounding. This type has no fields and is passed as an argument to various functions to indicate that discrete compounding should be used in calculations.\n\n\n\n\n\n","category":"type"},{"location":"fixed/#VLQuantitativeFinancePackage.ContinuousCompoundingModel","page":"Fixed Income","title":"VLQuantitativeFinancePackage.ContinuousCompoundingModel","text":"struct ContinuousCompoundingModel <: AbstractCompoundingModel\n\nImmutable type that represents continuous compounding.  This type has no fields and is passed as an argument to various functions to indicate that continuous compounding should be used in calculations.\n\n\n\n\n\n","category":"type"},{"location":"fixed/#Pricing-models","page":"Fixed Income","title":"Pricing models","text":"","category":"section"},{"location":"fixed/","page":"Fixed Income","title":"Fixed Income","text":"We model United States Treasury securities, e.g., Treasury bills, Treasury notes, and Treasury bonds using the MyUSTreasuryZeroCouponBondModel and MyUSTreasuryCouponSecurityModel types, which are subtypes of the AbstractTreasuryDebtSecurity abstract type.  ","category":"page"},{"location":"fixed/","page":"Fixed Income","title":"Fixed Income","text":"VLQuantitativeFinancePackage.MyUSTreasuryZeroCouponBondModel\nVLQuantitativeFinancePackage.MyUSTreasuryCouponSecurityModel","category":"page"},{"location":"fixed/#VLQuantitativeFinancePackage.MyUSTreasuryZeroCouponBondModel","page":"Fixed Income","title":"VLQuantitativeFinancePackage.MyUSTreasuryZeroCouponBondModel","text":"mutable struct MyUSTreasuryZeroCouponBondModel <: AbstractTreasuryDebtSecurity\n\nA mutable struct that represents a U.S. Treasury zero coupon security. \n\nFields\n\npar::Float64: The face or par value of the bond\nrate::Union{Nothing, Float64}: Effective annual interest rate (discount rate specified as a decimal)\nT::Union{Nothing,Float64}: Duration in years of the instrument, measured as a 365 day or a 52 week year\nprice::Union{Nothing, Float64}: Price of the bond or note (computed property)\nn::Int: Number of compounding periods per year (typically 2)\ncashflow::Union{Nothing, Dict{Int,Float64}}: Cashflow dictionary (computed property) where the key is the period and the value is the discounted cashflow in a period\ndiscount::Union{Nothing, Dict{Int,Float64}}: Discount factor dictionary (computed property) where the key is the period and the value is the discount factor in that period\n\n\n\n\n\n","category":"type"},{"location":"fixed/#VLQuantitativeFinancePackage.MyUSTreasuryCouponSecurityModel","page":"Fixed Income","title":"VLQuantitativeFinancePackage.MyUSTreasuryCouponSecurityModel","text":"mutable struct MyUSTreasuryCouponSecurityModel <: AbstractTreasuryDebtSecurity\n\nA mutable struct that represents a U.S. Treasury coupon bond.  This type of security (note or bond) pays the holder of the instrument a fixed interest rate at regular intervals over the life of the security.\n\nFields\n\npar::Float64: Par value of the bond\nrate::Union{Nothing, Float64}: Annualized effective discount rate\ncoupon::Union{Nothing, Float64}: Coupon interest rate\nT::Union{Nothing,Float64}: Duration in years of the note or bond, measured as a 365 day or a 52 week year\nλ::Int: Number of coupon payments per year (typically 2)\nprice::Union{Nothing, Float64}: Price of the bond or note\ncashflow::Union{Nothing, Dict{Int,Float64}}: Cashflow dictionary (computed property) where the key is the period and the value is the discounted cashflow in a period\ndiscount::Union{Nothing, Dict{Int,Float64}}: Discount factor dictionary(computed property) where the key is the period and the value is the discount factor in that period\n\n\n\n\n\n","category":"type"},{"location":"fixed/","page":"Fixed Income","title":"Fixed Income","text":"We construct MyUSTreasuryZeroCouponBondModel and MyUSTreasuryCouponSecurityModel objects by specifying the maturity date, the face value of the bond the effective annual interest rate and other data that are specific to the bill, note or bond in a build function where the data is  specified in a NamedTuple format. ","category":"page"},{"location":"fixed/","page":"Fixed Income","title":"Fixed Income","text":"For example, let's compute the price and cashflow for a T = 20-yr bond, with a coupon rate of c = 1.750%, a yield (discount rate) rate = 1.850%, two coupon payments per year, i.e., lambda = 2 and a face (par) value of V_P = 100 USD","category":"page"},{"location":"fixed/","page":"Fixed Income","title":"Fixed Income","text":"test_bond = build(MyUSTreasuryCouponSecurityModel, (\n    T = 20.0, rate = 0.01850, coupon = 0.01750, λ = 2, par = 100.0\n)) |> discount_model;","category":"page"},{"location":"fixed/","page":"Fixed Income","title":"Fixed Income","text":"VLQuantitativeFinancePackage.price\nVLQuantitativeFinancePackage.strip","category":"page"},{"location":"fixed/#VLQuantitativeFinancePackage.price","page":"Fixed Income","title":"VLQuantitativeFinancePackage.price","text":"price(model::MyUSTreasuryCouponSecurityModel, compounding::T) -> MyUSTreasuryCouponSecurityModel where T <: AbstractCompoundingModel\n\nThe price(...) function computes the price of a MyUSTreasuryCouponSecurityModel instance using a discrete or continuous compounding model.\n\nArguments\n\nmodel::MyUSTreasuryCouponSecurityModel: an instance of the MyUSTreasuryCouponSecurityModel type.\ncompounding::T: an instance of a type that is a subtype of AbstractCompoundingModel, i.e., a discrete or continuous compounding model.\n\nReturns\n\nMyUSTreasuryCouponSecurityModel: an updated instance of the MyUSTreasuryCouponSecurityModel type with the price computed using the compounding model.\n\n\n\n\n\nprice(model::MyUSTreasuryZeroCouponBondModel, compounding::T) -> MyUSTreasuryZeroCouponBondModel where T <: AbstractCompoundingModel\n\nThe price(...) function computes the price of a MyUSTreasuryZeroCouponBondModel instance using a discrete or continuous compounding model.\n\nArguments\n\nmodel::MyUSTreasuryZeroCouponBondModel: an instance of the MyUSTreasuryZeroCouponBondModel type.\ncompounding::T: an instance of a type that is a subtype of AbstractCompoundingModel, i.e., a discrete or continuous compounding model.\n\nReturns\n\nMyUSTreasuryZeroCouponBondModel: an updated instance of the MyUSTreasuryZeroCouponBondModel type with the price computed using the compounding model.\n\n\n\n\n\n","category":"function"},{"location":"fixed/#VLQuantitativeFinancePackage.strip","page":"Fixed Income","title":"VLQuantitativeFinancePackage.strip","text":"strip(model::MyUSTreasuryCouponSecurityModel) -> Dict{Int, MyUSTreasuryZeroCouponBondModel}\n\nStrips the coupon and par value payments from a parent coupon security. \n\nThe strip(...) function takes a model::MyUSTreasuryCouponSecurityModel of the security we wish to strip and returns a Dictionary  holding MyUSTreasuryZeroCouponBondModel instances created from the parent security.  The keys of the dictionary correspond to the temporal index of the created security.\n\n\n\n\n\n","category":"function"},{"location":"#VLQuantitativeFinancePackage.jl","page":"Home","title":"VLQuantitativeFinancePackage.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The VLQuantitativeFinancePackage.jl package is a Julia package that provides a collection of functions and types useful for quantitative finance. The package is designed to be simple and easy to use, and it is suitable for students, researchers, and practitioners in the area of quantitative finance.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed by running the following command in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/varnerlab/VLQuantitativeFinancePackage.jl.git\")","category":"page"},{"location":"#Disclaimer-and-Risks","page":"Home","title":"Disclaimer and Risks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This content is offered solely for training and informational purposes. No offer or solicitation to buy or sell securities or derivative products or any investment or trading advice or strategy is made, given, or endorsed by the teaching team. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Trading involves risk. Carefully review your financial situation before investing in securities, futures contracts, options, or commodity interests. Past performance, whether actual or indicated by historical tests of strategies, is no guarantee of future performance or success. Trading is generally inappropriate for someone with limited resources, investment or trading experience, or a low-risk tolerance.  Only risk capital that is not required for living expenses.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You are fully responsible for any investment or trading decisions you make. Such decisions should be based solely on evaluating your financial circumstances, investment or trading objectives, risk tolerance, and liquidity needs. You are responsible for conducting your own independent research and seeking the advice of a qualified professional before making any investment or trading decisions.","category":"page"}]
}

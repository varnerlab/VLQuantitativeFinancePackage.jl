var documenterSearchIndex = {"docs":
[{"location":"derivatives/#Derivative-Securities","page":"Derivative securities","title":"Derivative Securities","text":"","category":"section"},{"location":"derivatives/","page":"Derivative securities","title":"Derivative securities","text":"Derivatives are financial instruments based on the value of other assets like commodities, stocks, or market indexes. Options are a type of derivative that uses stock as its underlying asset. They are contractual agreements giving the buyer the right, but not the obligation, to execute a transaction at a later date. ","category":"page"},{"location":"derivatives/#Options-contracts","page":"Derivative securities","title":"Options contracts","text":"","category":"section"},{"location":"derivatives/","page":"Derivative securities","title":"Derivative securities","text":"Options contracts are financial instruments that give the holder the right to buy or sell an asset at a predetermined price on or before a specific date. The two main types of options are call options and put options. ","category":"page"},{"location":"derivatives/","page":"Derivative securities","title":"Derivative securities","text":"Call options give the holder the right to buy an asset at a predetermined price on or before the expiration date.\nPut options give the holder the right to sell an asset at a predetermined price on or before the expiration date.","category":"page"},{"location":"derivatives/#European-option-contracts","page":"Derivative securities","title":"European option contracts","text":"","category":"section"},{"location":"derivatives/","page":"Derivative securities","title":"Derivative securities","text":"European options are contracts that give the holder the right to buy or sell an asset at a predetermined price on the expiration date. ","category":"page"},{"location":"derivatives/","page":"Derivative securities","title":"Derivative securities","text":"VLQuantitativeFinancePackage.MyEuropeanCallContractModel\nVLQuantitativeFinancePackage.MyEuropeanPutContractModel\nVLQuantitativeFinancePackage.build(model::Type{MyEuropeanCallContractModel}, data::NamedTuple)\nVLQuantitativeFinancePackage.build(model::Type{MyEuropeanPutContractModel}, data::NamedTuple)","category":"page"},{"location":"derivatives/#VLQuantitativeFinancePackage.MyEuropeanCallContractModel","page":"Derivative securities","title":"VLQuantitativeFinancePackage.MyEuropeanCallContractModel","text":"mutable struct MyEuropeanCallContractModel <: AbstractContractModel\n\nThe MyEuropeanCallContractModel mutable struct represents a European call option contract. A call option is a financial contract that gives the holder the right, but not the obligation, to buy an asset at a specified price (the strike price)  within a specified time period. For European options, the contract can only be exercised by the buyer at the expiration date.\n\nRequired fields\n\nK::Float64: The strike price of the option. \n\nOptional fields\n\nsense::Union{Nothing, Int64}: The sense of the option. A value of 1 indicates a long position, and a value of -1 indicates a short position.\nDTE::Union{Nothing,Float64}: The days to expiration of the option (measured in units of years).\nIV::Union{Nothing, Float64}: The implied volatility of the option contract.\npremium::Union{Nothing, Float64}: The premium of the option contract. This is the price paid to the seller by the buyer for the option contract.\nticker::Union{Nothing,String}: The ticker symbol of the underlying asset.\ncopy::Union{Nothing, Int64}: Number of contracts purchased or sold.\n\n\n\n\n\n","category":"type"},{"location":"derivatives/#VLQuantitativeFinancePackage.MyEuropeanPutContractModel","page":"Derivative securities","title":"VLQuantitativeFinancePackage.MyEuropeanPutContractModel","text":"mutable struct MyEuropeanPutContractModel <: AbstractContractModel\n\nThe MyEuropeanPutContractModel mutable struct represents a European put option contract.  A put option is a financial contract that gives the holder the right, but not the obligation, to sell an asset at a specified price (the strike price) within a specified time period. For European options, the contract can only be exercised by the buyer at the expiration date.\n\nRequired fields\n\nK::Float64: The strike price of the option.\n\nOptional fields\n\nsense::Union{Nothing, Int64}: The sense of the option. A value of 1 indicates a long position, and a value of -1 indicates a short position.\nDTE::Union{Nothing,Float64}: The days to expiration of the option (measured in units of years).\nIV::Union{Nothing, Float64}: The implied volatility of the option contract.\npremium::Union{Nothing, Float64}: The premium of the option contract. This is the price paid to the seller by the buyer for the option contract.\nticker::Union{Nothing,String}: The ticker symbol of the underlying asset.\ncopy::Union{Nothing, Int64}: Number of contracts purchased or sold.\n\n\n\n\n\n","category":"type"},{"location":"derivatives/#VLQuantitativeFinancePackage.build-Tuple{Type{MyEuropeanCallContractModel}, NamedTuple}","page":"Derivative securities","title":"VLQuantitativeFinancePackage.build","text":"build(model::Type{MyEuropeanCallContractModel}, data::NamedTuple) -> MyEuropeanCallContractModel\n\nThis build method constructs an instance of the MyEuropeanCallContractModel type using the data in a NamedTuple.\n\nArguments\n\nmodel::Type{MyEuropeanCallContractModel}: The type of model to build.\ndata::NamedTuple: The data to use to build the model.\n\nThe data::NamedTuple must contain the following keys:\n\nK::Float64: The strike price of the contract.\n\nThe other fields of the MyEuropeanCallContractModel model are set to nothing by default.  These optional fields can be updated by the user after the model is built, or by passing the values in the data::NamedTuple argument.\n\n\n\n\n\n","category":"method"},{"location":"derivatives/#VLQuantitativeFinancePackage.build-Tuple{Type{MyEuropeanPutContractModel}, NamedTuple}","page":"Derivative securities","title":"VLQuantitativeFinancePackage.build","text":"build(model::Type{MyEuropeanPutContractModel}, data::NamedTuple) -> MyEuropeanPutContractModel\n\nThis build method constructs an instance of the MyEuropeanPutContractModel type using the data in a NamedTuple. \n\nArguments\n\nmodel::Type{MyEuropeanPutContractModel}: The type of model to build.\ndata::NamedTuple: The data to use to build the model.\n\nThe data::NamedTuple must contain the following keys:\n\nK::Float64: The strike price of the contract.\n\nThe other fields of the MyEuropeanPutContractModel model are set to nothing by default. These optional fields can be updated by the user after the model is built, or by passing the values in the data::NamedTuple argument.\n\n\n\n\n\n","category":"method"},{"location":"derivatives/#American-option-contracts","page":"Derivative securities","title":"American option contracts","text":"","category":"section"},{"location":"derivatives/","page":"Derivative securities","title":"Derivative securities","text":"American options are contracts that give the holder the right to buy or sell an asset at a predetermined price at any time before the expiration date.","category":"page"},{"location":"derivatives/","page":"Derivative securities","title":"Derivative securities","text":"VLQuantitativeFinancePackage.MyAmericanCallContractModel\nVLQuantitativeFinancePackage.MyAmericanPutContractModel\nVLQuantitativeFinancePackage.build(model::Type{MyAmericanCallContractModel}, data::NamedTuple)\nVLQuantitativeFinancePackage.build(model::Type{MyAmericanPutContractModel}, data::NamedTuple)","category":"page"},{"location":"derivatives/#VLQuantitativeFinancePackage.MyAmericanCallContractModel","page":"Derivative securities","title":"VLQuantitativeFinancePackage.MyAmericanCallContractModel","text":"mutable struct MyAmericanCallContractModel <: AbstractContractModel\n\nThe MyAmericanCallContractModel mutable struct represents an American call option contract.  An American call option is a financial contract that gives the holder the right, but not the obligation, to buy an asset at a specified price (the strike price). American option contracts can be exercised at any time on or before the expiration date.\n\nRequired fields\n\nK::Float64: The strike price of the option.\n\nOptional fields\n\nsense::Union{Nothing, Int64}: The sense of the option. A value of 1 indicates a long position, and a value of -1 indicates a short position.\nDTE::Union{Nothing,Float64}: The days to expiration of the option (measured in units of years).\nIV::Union{Nothing, Float64}: The implied volatility of the option contract.\npremium::Union{Nothing, Float64}: The premium of the option contract. This is the price paid to the seller by the buyer for the option contract.\nticker::Union{Nothing,String}: The ticker symbol of the underlying asset.\ncopy::Union{Nothing, Int64}: Number of contracts purchased or sold.\n\n\n\n\n\n","category":"type"},{"location":"derivatives/#VLQuantitativeFinancePackage.MyAmericanPutContractModel","page":"Derivative securities","title":"VLQuantitativeFinancePackage.MyAmericanPutContractModel","text":"mutable struct MyAmericanPutContractModel <: AbstractContractModel\n\nThe MyAmericanPutContractModel mutable struct represents an American put option contract.  A put option is a financial contract that gives the holder the right, but not the obligation, to sell an asset at a specified price (the strike price). For American options, the contract can be exercised at any time on or before the expiration date.\n\nRequired fields\n\nK::Float64: The strike price of the option.\n\nOptional fields\n\nsense::Union{Nothing, Int64}: The sense of the option. A value of 1 indicates a long position, and a value of -1 indicates a short position.\nDTE::Union{Nothing,Float64}: The days to expiration of the option (measured in units of years).\nIV::Union{Nothing, Float64}: The implied volatility of the option contract.\npremium::Union{Nothing, Float64}: The premium of the option contract. This is the price paid to the seller by the buyer for the option contract.\nticker::Union{Nothing,String}: The ticker symbol of the underlying asset.\ncopy::Union{Nothing, Int64}: Number of contracts purchased or sold.\n\n\n\n\n\n","category":"type"},{"location":"derivatives/#VLQuantitativeFinancePackage.build-Tuple{Type{MyAmericanCallContractModel}, NamedTuple}","page":"Derivative securities","title":"VLQuantitativeFinancePackage.build","text":"build(model::Type{MyAmericanCallContractModel}, data::NamedTuple) -> MyAmericanCallContractModel\n\nThis build method constructs an instance of the MyAmericanCallContractModel type using the data in a NamedTuple.\n\nArguments\n\nmodel::Type{MyAmericanCallContractModel}: The type of model to build.\ndata::NamedTuple: The data to use to build the model.\n\nThe data::NamedTuple must contain the following keys:\n\nK::Float64: The strike price of the contract.\n\nThe other fields of the MyAmericanCallContractModel model are set to nothing by default. These optional fields can be updated by the user after the model is built, or by passing the values in the data::NamedTuple argument.\n\n\n\n\n\n","category":"method"},{"location":"derivatives/#VLQuantitativeFinancePackage.build-Tuple{Type{MyAmericanPutContractModel}, NamedTuple}","page":"Derivative securities","title":"VLQuantitativeFinancePackage.build","text":"build(model::Type{MyAmericanPutContractModel}, data::NamedTuple) -> MyAmericanPutContractModel\n\nThis build method constructs an instance of the MyAmericanPutContractModel type using the data in a NamedTuple.\n\nArguments\n\nmodel::Type{MyAmericanPutContractModel}: The type of model to build.\ndata::NamedTuple: The data to use to build the model.\n\nThe data::NamedTuple must contain the following keys:\n\nK::Float64: The strike price of the contract.\n\nThe other fields of the MyAmericanPutContractModel model are set to nothing by default.  These optional fields can be updated by the user after the model is built, or by passing the values in the data::NamedTuple argument.\n\n\n\n\n\n","category":"method"},{"location":"derivatives/#Contracts-at-expiration","page":"Derivative securities","title":"Contracts at expiration","text":"","category":"section"},{"location":"derivatives/","page":"Derivative securities","title":"Derivative securities","text":"VLQuantitativeFinancePackage.payoff\nVLQuantitativeFinancePackage.profit","category":"page"},{"location":"derivatives/#VLQuantitativeFinancePackage.payoff","page":"Derivative securities","title":"VLQuantitativeFinancePackage.payoff","text":"payoff(contracts::Array{T,1}, S::Array{Float64,1}) -> Array{Float64,2} where T <: AbstractContractModel\n\nThe payoff function computes the payoff for a set of option contracts at expiration given the underlying prices contained in the S::Array{Float64,1} array.\n\nArguments\n\ncontracts::Array{T,1}: An array of option contracts where T is a subtype of the AbstractContractModel type.\nS::Array{Float64,1}: An array of underlying prices.\n\nReturns\n\nArray{Float64,2}: A matrix of size (number_of_underlying_prices, number_of_contracts + 2) where each row represents an underlying price and each column containts the payoff for each contract. \n\nThe first column contains the underlying price, the second column contains the payoff for the first contract, the third column contains the payoff for the second contract, and so on. The last column contains the sum of the payoffs for all contracts.\n\n\n\n\n\n","category":"function"},{"location":"derivatives/#VLQuantitativeFinancePackage.profit","page":"Derivative securities","title":"VLQuantitativeFinancePackage.profit","text":"profit(contracts::Array{T,1}, S::Array{Float64,1}) -> Array{Float64,2} where T <: AbstractContractModel\n\nThe profit function computes the profit for a set of option contracts at expiration given the underlying prices contained in the S::Array{Float64,1} array. This function requires the contracts to have the premium field set on each contract model.\n\nArguments\n\ncontracts::Array{T,1}: An array of option contracts where T is a subtype of the AbstractContractModel type. Each contract must have the premium field set.\nS::Array{Float64,1}: An array of underlying prices at expiration.\n\nReturns\n\nArray{Float64,2}: A matrix of size (number_of_underlying_prices, number_of_contracts + 2) where each row represents an underlying price and each column containts the profit for a contract.\n\nThe first column contains the underlying price, the second column contains the profit for the first contract, the third column contains the profit for the second contract, and so on. The last column contains the sum of the profits for all contracts.\n\n\n\n\n\n","category":"function"},{"location":"derivatives/#European-contract-premiums","page":"Derivative securities","title":"European contract premiums","text":"","category":"section"},{"location":"derivatives/","page":"Derivative securities","title":"Derivative securities","text":"VLQuantitativeFinancePackage.MyBlackScholesContractPricingModel\nVLQuantitativeFinancePackage.premium(contract::MyEuropeanCallContractModel, \n    model::MyBlackScholesContractPricingModel; sigdigits::Int64 = 4)\nVLQuantitativeFinancePackage.premium(contract::MyEuropeanPutContractModel, \n    model::MyBlackScholesContractPricingModel; sigdigits::Int64 = 4)","category":"page"},{"location":"derivatives/#VLQuantitativeFinancePackage.MyBlackScholesContractPricingModel","page":"Derivative securities","title":"VLQuantitativeFinancePackage.MyBlackScholesContractPricingModel","text":"mutable struct MyBlackScholesContractPricingModel <: AbstractAssetModel\n\nThe MyBlackScholesContractPricingModel mutable struct represents a Black-Scholes model for pricing European option contracts. \n\nRequired fields\n\nr::Float64: The annual risk-free discount rate\nSₒ::Float64: The current price of the underlying asset\n\n\n\n\n\n","category":"type"},{"location":"derivatives/#VLQuantitativeFinancePackage.premium-Tuple{MyEuropeanCallContractModel, MyBlackScholesContractPricingModel}","page":"Derivative securities","title":"VLQuantitativeFinancePackage.premium","text":"premium(contract::MyEuropeanCallContractModel, \n    model::MyBlackScholesContractPricingModel; sigdigits::Int64 = 4)\n\nThe premium function computes the premium for a European call option contract using the Black-Scholes-Merton model. This function requires the contract to have the K, DTE, and IV fields set on the contract model, and the Sₒ and r fields set on the pricing model::MyBlackScholesContractPricingModel instance.\n\nArguments\n\ncontract::MyEuropeanCallContractModel: An instance of the MyEuropeanCallContractModel type which models the European call option contract.\nmodel::MyBlackScholesContractPricingModel: An instance of the MyBlackScholesContractPricingModel type which models the Black-Scholes-Merton model calculation.\n\nReturns\n\nFloat64: The premium for the European call option contract.\n\n\n\n\n\n","category":"method"},{"location":"derivatives/#VLQuantitativeFinancePackage.premium-Tuple{MyEuropeanPutContractModel, MyBlackScholesContractPricingModel}","page":"Derivative securities","title":"VLQuantitativeFinancePackage.premium","text":"premium(contract::MyEuropeanPutContractModel, \n    model::MyBlackScholesContractPricingModel; sigdigits::Int64 = 4) -> Float64\n\nThe premium function computes the premium for a European put option contract using the Black-Scholes-Merton model. This function requires the contract to have the K, DTE, and IV fields set on the contract model, and the Sₒ and r fields set on the pricing model::MyBlackScholesContractPricingModel instance.\n\nArguments\n\ncontract::MyEuropeanPutContractModel: An instance of the MyEuropeanPutContractModel type which models the European put option contract.\nmodel::MyBlackScholesContractPricingModel: An instance of the MyBlackScholesContractPricingModel type which models the Black-Scholes-Merton model calculation.\n\nReturns\n\nFloat64: The premium for the European put option contract.\n\n\n\n\n\n","category":"method"},{"location":"derivatives/#American-contract-premiums","page":"Derivative securities","title":"American contract premiums","text":"","category":"section"},{"location":"derivatives/","page":"Derivative securities","title":"Derivative securities","text":"VLQuantitativeFinancePackage.MyAdjacencyBasedCRREquityPriceTree\nVLQuantitativeFinancePackage.MyCRRLatticeNodeModel\nVLQuantitativeFinancePackage.build(model::Type{MyAdjacencyBasedCRREquityPriceTree}, data::NamedTuple)\nVLQuantitativeFinancePackage.populate(model::MyAdjacencyBasedCRREquityPriceTree; \n    Sₒ::Float64 = 100.0, h::Int64 = 1)\nVLQuantitativeFinancePackage.premium","category":"page"},{"location":"derivatives/#VLQuantitativeFinancePackage.MyAdjacencyBasedCRREquityPriceTree","page":"Derivative securities","title":"VLQuantitativeFinancePackage.MyAdjacencyBasedCRREquityPriceTree","text":"mutable struct MyAdjacencyBasedCRREquityPriceTree <: AbstractEquityPriceTreeModel\n\nThe MyAdjacencyBasedCRREquityPriceTree mutable struct represents a Cox-Ross-Rubinstein (CRR) model for pricing American style option contracts. The lattice is constructed using an adjacency list to represent the connectivity of the nodes in the lattice. The lattice is populated using the populate function, and the contract pricing is performed using the premium function.\n\nRequired fields\n\nμ::Float64: The drift rate of the asset price\nσ::Float64: The volatility of the asset price\nT::Float64: The time to expiration of the option contract (measured in units of years)\n\nOptional or computed fields\n\nΔT::Union{Nothing,Float64}: The time step size\nu::Union{Nothing,Float64}: The up-factor for the lattice\nd::Union{Nothing,Float64}: The down-factor for the lattice\np::Union{Nothing,Float64}: The probability of an up move in the lattice\ndata::Union{Nothing, Dict{Int, MyCRRLatticeNodeModel}}: A dictionary that holds the lattice data for each node where nodes are modeled as MyCRRLatticeNodeModel instances.\nconnectivity::Union{Nothing, Dict{Int64, Array{Int64,1}}}: A dictionary that holds the connectivity of the lattice where the key is the node index and the value is an array of the connected nodes.\nlevels::Union{Nothing, Dict{Int64,Array{Int64,1}}}: A dictionary that holds the nodes on each level of the lattice where the key is the level index and the value is an array of the nodes on that level.\n\nThe optional fields are computed when the lattice is passed to the populate function.\n\n\n\n\n\n","category":"type"},{"location":"derivatives/#VLQuantitativeFinancePackage.MyCRRLatticeNodeModel","page":"Derivative securities","title":"VLQuantitativeFinancePackage.MyCRRLatticeNodeModel","text":"mutable struct MyCRRLatticeNodeModel\n\nThe MyCRRLatticeNodeModel mutable struct represents a node in a Cox-Ross-Rubinstein (CRR) model for pricing American style option contracts.\n\nRequired fields\n\nprice::Float64: The price of the price at the node\nprobability::Float64: The probability of reaching the node\n\nOptional or computed fields\n\nintrinsic::Union{Nothing,Float64}: The intrinsic value of the option contract at the node\nextrinsic::Union{Nothing,Float64}: The extrinsic value of the option contract at the node\n\n\n\n\n\n","category":"type"},{"location":"derivatives/#VLQuantitativeFinancePackage.build-Tuple{Type{MyAdjacencyBasedCRREquityPriceTree}, NamedTuple}","page":"Derivative securities","title":"VLQuantitativeFinancePackage.build","text":"build(model::Type{MyAdjacencyBasedCRREquityPriceTree}, data::NamedTuple) -> MyAdjacencyBasedCRREquityPriceTree\n\nThis build method constructs an instance of the MyAdjacencyBasedCRREquityPriceTree type using the data in a NamedTuple.\n\nArguments\n\nmodel::Type{MyAdjacencyBasedCRREquityPriceTree}: The type of model to build.\ndata::NamedTuple: The data to use to build the model.\n\nThe data::NamedTuple must contain the following keys:\n\nμ::Float64: The drift rate of the asset price. For a risk-neutral measure, this is the risk-free rate.\nσ::Float64: The volatility of the asset price. This is the implied volatility for a risk-neutral measure.\nT::Float64: The time to expiration of the option contract (measured in units of years)\n\n\n\n\n\n","category":"method"},{"location":"derivatives/#VLQuantitativeFinancePackage.populate-Tuple{MyAdjacencyBasedCRREquityPriceTree}","page":"Derivative securities","title":"VLQuantitativeFinancePackage.populate","text":"populate(model::MyAdjacencyBasedCRREquityPriceTree; \n    Sₒ::Float64 = 100.0, h::Int64 = 1)\n\nThe populate function initializes the MyAdjacencyBasedCRREquityPriceTree model with share prices and probabilities for each node in the lattice. In addition, this methods sets the intrinsic and extrinsic values of each node to 0.0 and computes the connectivity and levels of the lattice.\n\nArguments\n\nmodel::MyAdjacencyBasedCRREquityPriceTree: An instance of the MyAdjacencyBasedCRREquityPriceTree type.\nSₒ::Float64 = 100.0: The initial price of the equity.\nh::Int64 = 1: The number of time steps in the lattice (the height of the binomial price tree).\n\nReturns\n\nMyAdjacencyBasedCRREquityPriceTree: An updated instance of the MyAdjacencyBasedCRREquityPriceTree type with the share prices and probabilities computed for each node in the lattice.\n\n\n\n\n\n","category":"method"},{"location":"derivatives/#VLQuantitativeFinancePackage.premium","page":"Derivative securities","title":"VLQuantitativeFinancePackage.premium","text":"premium(contract::T, model::MyAdjacencyBasedCRREquityPriceTree; \n    choice::Function=_rational, sigdigits::Int64 = 4) -> Float64 where {T<:AbstractContractModel}\n\nComputes the premium for an American style option contract using the Cox-Ross-Rubinstein model.\n\nArguments\n\ncontract::T: An instance of the AbstractContractModel type which models the option contract. \nmodel::MyAdjacencyBasedCRREquityPriceTree: An instance of the MyAdjacencyBasedCRREquityPriceTree type which models the Cox-Ross-Rubinstein model.\nchoice::Function=_rational: A function that determines the choice of the option contract. Default value is _rational.\nsigdigits::Int64 = 4: The number of significant digits to round the premium to. Default value is 4.\n\nReturns\n\nFloat64: The premium for the American style option contract.\n\n\n\n\n\npremium(contract::MyEuropeanCallContractModel, \n    model::MyBlackScholesContractPricingModel; sigdigits::Int64 = 4)\n\nThe premium function computes the premium for a European call option contract using the Black-Scholes-Merton model. This function requires the contract to have the K, DTE, and IV fields set on the contract model, and the Sₒ and r fields set on the pricing model::MyBlackScholesContractPricingModel instance.\n\nArguments\n\ncontract::MyEuropeanCallContractModel: An instance of the MyEuropeanCallContractModel type which models the European call option contract.\nmodel::MyBlackScholesContractPricingModel: An instance of the MyBlackScholesContractPricingModel type which models the Black-Scholes-Merton model calculation.\n\nReturns\n\nFloat64: The premium for the European call option contract.\n\n\n\n\n\npremium(contract::MyEuropeanPutContractModel, \n    model::MyBlackScholesContractPricingModel; sigdigits::Int64 = 4) -> Float64\n\nThe premium function computes the premium for a European put option contract using the Black-Scholes-Merton model. This function requires the contract to have the K, DTE, and IV fields set on the contract model, and the Sₒ and r fields set on the pricing model::MyBlackScholesContractPricingModel instance.\n\nArguments\n\ncontract::MyEuropeanPutContractModel: An instance of the MyEuropeanPutContractModel type which models the European put option contract.\nmodel::MyBlackScholesContractPricingModel: An instance of the MyBlackScholesContractPricingModel type which models the Black-Scholes-Merton model calculation.\n\nReturns\n\nFloat64: The premium for the European put option contract.\n\n\n\n\n\n","category":"function"},{"location":"derivatives/#Implied-volatility","page":"Derivative securities","title":"Implied volatility","text":"","category":"section"},{"location":"derivatives/","page":"Derivative securities","title":"Derivative securities","text":"VLQuantitativeFinancePackage.estimate_implied_volatility","category":"page"},{"location":"derivatives/#VLQuantitativeFinancePackage.estimate_implied_volatility","page":"Derivative securities","title":"VLQuantitativeFinancePackage.estimate_implied_volatility","text":"estimate_implied_volatility(contract::T; Sₒ::Float64 = 100.0, h::Int64 = 1, r̄::Float64 = 0.05) -> Tuple{Float64,Float64} where {T<:AbstractContractModel}\n\nThe estimate_implied_volatility function estimates the implied volatility for a given contract using the Nelder-Mead optimization algorithm. \n\nArguments\n\ncontract::T: An instance of a contract model that defines the contract parameters, where T is a subtype of the AbstractContractModel type.\nSₒ::Float64: The initial stock price used to compute the premium. The default value is 100.0.\nh::Int64: The height of the lattice model used to compute the premium. The default value is 1.\nr̄::Float64: The annual risk-free rate used to compute the premium. The default value is 0.05.  \n\nReturns\n\nTuple{Float64,Float64}: The likelihood and estimated implied volatility for the given contract.\n\nSee:\n\nWe use the Nelder-Mead optimization algorithm from the Optim.jl package to estimate the implied volatility.\n\n\n\n\n\n","category":"function"},{"location":"derivatives/#The-Greeks","page":"Derivative securities","title":"The Greeks","text":"","category":"section"},{"location":"derivatives/","page":"Derivative securities","title":"Derivative securities","text":"The Greeks quantify the sensitivity of an option's premium to various factors. Delta, theta, vega, rho and gamma are the most widely used Greeks, measuring an option's sensitivity to changes in the underlying asset's share price, the time decay, implied volatility, the risk-free rate and the rate of change in delta, respectively. ","category":"page"},{"location":"derivatives/","page":"Derivative securities","title":"Derivative securities","text":"VLQuantitativeFinancePackage.delta\nVLQuantitativeFinancePackage.theta\nVLQuantitativeFinancePackage.vega\nVLQuantitativeFinancePackage.rho\nVLQuantitativeFinancePackage.gamma","category":"page"},{"location":"derivatives/#VLQuantitativeFinancePackage.delta","page":"Derivative securities","title":"VLQuantitativeFinancePackage.delta","text":"delta(contract::Y; h::Int64=2, T::Float64=(1 / 365), σ::Float64=0.15,\n    Sₒ::Float64=1.0, μ::Float64=0.0015, choice::Function=_rational)::Float64 where {Y<:AbstractContractModel}\n\nCompute the delta of a contract using the Cox-Ross-Rubinstein binomial tree method. Delta measures the change in the options premium for a 1 USD/share change in the underlying price, and is defined as:\n\nDelta(star) = fracpartialmathcalPpartialSBigr_star\n\nwhere star is the current state of the system, i.e., the current underlying price, time to maturity, implied volatility, and risk-free rate.\n\nArguments\n\ncontract::Y: The contract model for which we compute the delta where Y is a subtype of AbstractContractModel.\nh::Int64=2: The number of levels in the binomial tree.\nT::Float64 = (1 / 365): The time to maturity for the options contract measured in years, assume a 365-day year.\nσ::Float64 = 0.15: The implied volatility (IV) for the options contract\nSₒ::Float64 = 1.0: Initial share price of the underlying at the time contract was purchased\nμ::Float64 = 0.0015: Single-step growth rate. Equals the risk-free rate for risk-neutral options evaluation\n\nReturn\n\nΔ::Float64: The delta value for this option contract\n\nSee also:\n\nWhat is Delta?\n\n\n\n\n\n","category":"function"},{"location":"derivatives/#VLQuantitativeFinancePackage.theta","page":"Derivative securities","title":"VLQuantitativeFinancePackage.theta","text":"theta(contract::Y; h::Int64=2, T::Float64=(1 / 365), σ::Float64=0.15,\n    Sₒ::Float64=1.0, μ::Float64=0.0015, choice::Function=_rational) -> Float64 where {Y<:AbstractContractModel}\n\nCompute the theta of a contract using the Cox-Ross-Rubinstein binomial tree method. Theta measures the rate of change in the options premium for a 1 day change in the time to maturity, and is defined as:\n\ntheta(star) = fracpartialmathcalPpartialTBigr_star\n\nwhere star is the current state of the system, i.e., the current underlying price, time to maturity, implied volatility, and risk-free rate.\n\nArguments\n\ncontract::Y: The contract model for which we compute the theta where Y is a subtype of AbstractContractModel.\nh::Int64=2: The number of levels in the binomial tree.\nT::Float64 = (1/365): The time to maturity for the options contract measured in years assuming a 365-day year.\nσ::Float64 = 0.15: The implied volatility (IV) for the options contract\nSₒ::Float64 = 1.0: Initial share price of the underlying at the time contract was purchased\nμ::Float64 = 0.0015: Single-step growth rate. Equals the risk-free rate for risk-neutral options evaluation\n\nReturn\n\nΘ::Float64: The theta value for this option contract\n\nSee also:\n\nWhat is Theta?\n\n\n\n\n\n","category":"function"},{"location":"derivatives/#VLQuantitativeFinancePackage.vega","page":"Derivative securities","title":"VLQuantitativeFinancePackage.vega","text":"vega(contract::Y; h::Int64=2, T::Float64=(1 / 365), σ::Float64=0.15,\n    Sₒ::Float64=1.0, μ::Float64=0.0015, choice::Function=_rational) -> Float64 where {Y<:AbstractContractModel}\n\nCompute the vega of a contract using the Cox-Ross-Rubinstein binomial tree method. Vega measures the rate of change in the options premium for a 1% change in the implied volatility, and is defined as:\n\nV(star) = fracpartialmathcalPpartialsigmaBigr_star\n\nwhere star is the current state of the system, i.e., the current underlying price, time to maturity, implied volatility, and risk-free rate.\n\nArguments\n\ncontract::Y: The contract model for which we compute the delta where Y is a subtype of AbstractContractModel.\nh::Int64=2: The number of levels in the binomial tree.\nT::Float64 = (1 / 365): The time to maturity for the options contract measured in years, assume a 365-day year.\nσ::Float64 = 0.15: The implied volatility (IV) for the options contract\nSₒ::Float64 = 1.0: Initial share price of the underlying at the time contract was purchased\nμ::Float64 = 0.0015: Single-step growth rate. Equals the risk-free rate for risk-neutral options evaluation\n\nReturn\n\nV::Float64: The vega value for this option contract\n\nSee also:\n\nWhat is Vega?\n\n\n\n\n\n","category":"function"},{"location":"derivatives/#VLQuantitativeFinancePackage.rho","page":"Derivative securities","title":"VLQuantitativeFinancePackage.rho","text":"rho(contract::Y; h::Int64=2, T::Float64=(1 / 365), σ::Float64=0.15,\n    Sₒ::Float64=1.0, μ::Float64=0.0015, choice::Function=_rational) -> Float64 where {Y<:AbstractContractModel}\n\nCompute the rho of a contract using the Cox-Ross-Rubinstein binomial tree method. Rho measures the rate of change in the options premium for a 1% change in the risk-free rate r_f, and is defined as:\n\ntextrho(star) = fracpartialmathcalPpartialr_fBigr_star\n\nwhere star is the current state of the system, i.e., the current underlying price, time to maturity, implied volatility, and risk-free rate.\n\nArguments\n\ncontract::Y: The contract model for which we compute the delta where Y is a subtype of AbstractContractModel.\nh::Int64=2: The number of levels in the binomial tree.\nT::Float64 = (1 / 365): The time to maturity for the options contract measured in years, assume a 365-day year.\nσ::Float64 = 0.15: The implied volatility (IV) for the options contract\nSₒ::Float64 = 1.0: Initial share price of the underlying at the time contract was purchased\nμ::Float64 = 0.0015: Single-step growth rate. Equals the risk-free rate for risk-neutral options evaluation\n\nReturn\n\nV::Float64: The vega value for this option contract\n\nSee also:\n\nWhat is Rho?\n\n\n\n\n\n","category":"function"},{"location":"derivatives/#VLQuantitativeFinancePackage.gamma","page":"Derivative securities","title":"VLQuantitativeFinancePackage.gamma","text":"gamma(contract::Y; h::Int64=2, T::Float64=(1 / 365), σ::Float64=0.15,\n    Sₒ::Float64=1.0, μ::Float64=0.0015, choice::Function=_rational) -> Float64 where {Y<:AbstractContractModel}\n\nCompute the gamma of a contract using the Cox-Ross-Rubinstein binomial tree method. Gamma measures the rate of change in the delta for a 1 USD/share change in the underlying price, and is defined as:\n\nGamma(star) = fracpartial^2mathcalPpartialS^2Bigr_star\n\nwhere star is the current state of the system, i.e., the current underlying price, time to maturity, implied volatility, and risk-free rate.\n\nArguments\n\ncontract::Y: The contract model for which we compute the delta where Y is a subtype of AbstractContractModel.\nh::Int64=2: The number of levels in the binomial tree.\nT::Float64 = (1 / 365): The time to maturity for the options contract measured in years, assume a 365-day year.\nσ::Float64 = 0.15: The implied volatility (IV) for the options contract\nSₒ::Float64 = 1.0: Initial share price of the underlying at the time contract was purchased\nμ::Float64 = 0.0015: Single-step growth rate. Equals the risk-free rate for risk-neutral options evaluation\n\nReturn\n\nΓ::Float64: The gamma value for this option contract\n\nSee also:\n\nWhat is Gamma?\n\n\n\n\n\n","category":"function"},{"location":"equity/#Equity-Securities","page":"Equity securities","title":"Equity Securities","text":"","category":"section"},{"location":"equity/","page":"Equity securities","title":"Equity securities","text":"This should update now.","category":"page"},{"location":"equity/#Computing-returns","page":"Equity securities","title":"Computing returns","text":"","category":"section"},{"location":"equity/","page":"Equity securities","title":"Equity securities","text":"Fill me in.","category":"page"},{"location":"equity/","page":"Equity securities","title":"Equity securities","text":"VLQuantitativeFinancePackage.log_growth_matrix\nVLQuantitativeFinancePackage.vwap","category":"page"},{"location":"equity/#VLQuantitativeFinancePackage.log_growth_matrix","page":"Equity securities","title":"VLQuantitativeFinancePackage.log_growth_matrix","text":"log_growth_matrix(dataset::Dict{String, DataFrame}, \n    firms::Array{String,1}; Δt::Float64 = (1.0/252.0), risk_free_rate::Float64 = 0.0) -> Array{Float64,2}\n\nThe log_growth_matrix function computes the excess log growth matrix for a given set of firms where we define the log growth as:\n\n    mu_tt-1(r_f) = frac1Delta t logleft(fracS_tS_t-1right) - r_f\n\nwhere S_t is the volume weighted average price (units: USD/share) at time t, Delta t is the time increment (in years), and r_f is the annual risk-free rate (units: 1/years) assuming continuous compounding.\n\nArguments\n\ndataset::Dict{String, DataFrame}: A dictionary of data frames where the keys are the firm ticker symbols and the values are the data frames holding price data. We use the volume_weighted_average_price column to compute the log growth by default.\nfirms::Array{String,1}: An array of firm ticker symbols for which we want to compute the log growth matrix.\nΔt::Float64: The time increment used to compute the log growth. The default value is 1/252, i.e., one trading day in units of years.\nrisk_free_rate::Float64: The risk-free rate used to compute the log growth. The default value is 0.0.\nkeycol::Symbol: The column in the data frame to use to compute the log growth. The default value is :volume_weighted_average_price.\ntestfirm::String: The firm ticker symbol to use to determine the number of trading days. By default, we use \"AAPL\".\n\nReturns\n\nArray{Float64,2}: An array of the excess log growth values for the given set of firms. The time series is the rows and the firms are the columns. The columns are ordered according to the order of the firms array.\n\nSee:\n\nThe DataFrame type (and methods for working with data frames) is exported from the DataFrames.jl package\n\n\n\n\n\nlog_growth_matrix(dataset::Dict{String, DataFrame}, \n    firm::String; Δt::Float64 = (1.0/252.0), risk_free_rate::Float64 = 0.0) -> Array{Float64,1}\n\nThe log_growth_matrix function computes the excess log growth matrix for a given firm where we define the log growth as:\n\n    mu_tt-1(r_f) = frac1Delta t logleft(fracS_tS_t-1right) - r_f\n\nwhere S_t is the volume weighted average price (units: USD/share) at time t, Delta t is the time increment (in years), and r_f is the annual risk-free rate (units: 1/years) assuming continuous compounding.\n\nArguments\n\ndataset::Dict{String, DataFrame}: A dictionary of data frames where the keys are the firm ticker symbols and the values are the data frames holding price data. We use the volume_weighted_average_price column to compute the log growth by default.\nfirm::String: The firm ticker symbol for which we want to compute the log growth matrix.\nΔt::Float64: The time increment used to compute the log growth. The default value is 1/252, i.e., one trading day in units of years.\nrisk_free_rate::Float64: The risk-free rate used to compute the log growth. The default value is 0.0.\nkeycol::Symbol: The column in the data frame to use to compute the log growth. The default value is :volume_weighted_average_price.\n\nReturns\n\nArray{Float64,1}: An array of the excess log growth values for the given firm.\n\nSee:\n\nThe DataFrame type (and methods for working with data frames) is exported from the DataFrames.jl package\n\n\n\n\n\nlog_growth_matrix(dataset::DataFrame; Δt::Float64 = (1.0/252.0), risk_free_rate::Float64 = 0.0,\n        keycol::Symbol = :volume_weighted_average_price) -> Array{Float64,1}\n\nCompute the log growth matrix for a given data frame. \n\n\n\n\n\nlog_growth_matrix(dataset::Array{Float64,1}, \n    Δt::Float64 = (1.0/252.0), risk_free_rate::Float64 = 0.0)::Array{Float64,1}\n\n\n\n\n\n","category":"function"},{"location":"equity/#VLQuantitativeFinancePackage.vwap","page":"Equity securities","title":"VLQuantitativeFinancePackage.vwap","text":"vwap(data::DataFrame) -> Array{Float64,1}\n\nThe vwap function computes the volume weighted average price (VWAP) for a given data frame.  The VWAP is calculated by multiplying the average price by the volume and then dividing by total volume per period.\n\nArguments\n\ndata::DataFrame: A data frame holding the price data. To compute the VWAP, we use the volume and open and close price fields.\n\nReturns\n\nArray{Float64,1}: An array of the VWAP values for the given data frame.\n\n\n\n\n\n","category":"function"},{"location":"equity/#Lattice-Models","page":"Equity securities","title":"Lattice Models","text":"","category":"section"},{"location":"equity/","page":"Equity securities","title":"Equity securities","text":"VLQuantitativeFinancePackage.RealWorldBinomialProbabilityMeasure\nVLQuantitativeFinancePackage.RiskNeutralBinomialProbabilityMeasure\nVLQuantitativeFinancePackage.MyBinomialEquityPriceTree\nVLQuantitativeFinancePackage.build(model::Type{MyBinomialEquityPriceTree}, data::NamedTuple)\nVLQuantitativeFinancePackage.sample(model::MyBinomialEquityPriceTree, L::Int64; \n    number_of_paths::Int64 = 100)","category":"page"},{"location":"equity/#VLQuantitativeFinancePackage.RealWorldBinomialProbabilityMeasure","page":"Equity securities","title":"VLQuantitativeFinancePackage.RealWorldBinomialProbabilityMeasure","text":"struct RealWorldBinomialProbabilityMeasure <: AbstractProbabilityMeasure\n\nImmutable type that represents the real-world probability measure.  This type is passed as an argument to various functions to indicate that the real-world probability measure should be used in calculations.   \n\n\n\n\n\n","category":"type"},{"location":"equity/#VLQuantitativeFinancePackage.RiskNeutralBinomialProbabilityMeasure","page":"Equity securities","title":"VLQuantitativeFinancePackage.RiskNeutralBinomialProbabilityMeasure","text":"struct RiskNeutralBinomialProbabilityMeasure <: AbstractProbabilityMeasure\n\nImmutable type that represents the risk-neutral probability measure.  This type is passed as an argument to various functions to indicate that the risk-neutral probability measure should be used in calculations.        \n\n\n\n\n\n","category":"type"},{"location":"equity/#VLQuantitativeFinancePackage.MyBinomialEquityPriceTree","page":"Equity securities","title":"VLQuantitativeFinancePackage.MyBinomialEquityPriceTree","text":"mutable struct MyBinomialEquityPriceTree <: AbstractEquityPriceTreeModel\n\nThis mutable struct represents a binomial lattice model for simulating equity prices. The lattice is constructed using values for the up-factor u, down-factor d, and probability p of an up move computed using either a real-world or risk-neutral probability measure.  A default (largely empty) lattice is created using a build method, and the lattice is populated using the populate function.\n\nRequired fields\n\nu::Float64: The up-factor for the lattice (return for an up move during a single time step)\nd::Float64: The down-factor for the lattice (return for a down move during a single time step)\np::Float64: The probability of an up move in the lattice\n\nOptional or computed fields\n\nμ::Union{Nothing,Float64}: The drift rate of the asset price (needed for option pricing)\nT::Union{Nothing,Float64}: The time to expiration of the option contract (needed for option pricing)\nconnectivity::Union{Nothing, Dict{Int64, Array{Int64,1}}}: A dictionary that holds the connectivity of the lattice where the key is the node index and the value is an array of the connected nodes.\nlevels::Union{Nothing, Dict{Int64,Array{Int64,1}}}: A dictionary that holds the nodes on each level of the lattice where the key is the level index and the value is an array of the nodes on that level.\nΔT::Union{Nothing,Float64}: The time step size for a single time step in the lattice\ndata::Union{Nothing, Dict{Int64, MyBiomialLatticeEquityNodeModel}}: A dictionary that holds the lattice data for each node where nodes are modeled as MyBiomialLatticeEquityNodeModel instances.         \n\n\n\n\n\n","category":"type"},{"location":"equity/#VLQuantitativeFinancePackage.build-Tuple{Type{MyBinomialEquityPriceTree}, NamedTuple}","page":"Equity securities","title":"VLQuantitativeFinancePackage.build","text":"build(model::Type{MyBinomialEquityPriceTree}, data::NamedTuple) -> MyBinomialEquityPriceTree\n\nThis build method constructs an instance of the MyBinomialEquityPriceTree type using the data in a NamedTuple.\n\nArguments\n\nmodel::Type{MyBinomialEquityPriceTree}: The type of model to build.\ndata::NamedTuple: The data to use to build the model.\n\nThe data::NamedTuple must contain the following keys:\n\nu::Float64: The up-factor for the lattice (return for an up move during a single time step)\nd::Float64: The down-factor for the lattice (return for a down move during a single time step)\np::Float64: The probability of an up move in the lattice\n\nThe other properties of the MyBinomialEquityPriceTree model are set to nothing by default and are populated during the construction of the model using the  populate method.\n\n\n\n\n\n","category":"method"},{"location":"equity/#VLQuantitativeFinancePackage.sample-Tuple{MyBinomialEquityPriceTree, Int64}","page":"Equity securities","title":"VLQuantitativeFinancePackage.sample","text":"sample(model::MyBinomialEquityPriceTree, L::Int64; number_of_paths::Int64 = 100) -> Array{Float64,2}\n\n\n\n\n\n","category":"method"},{"location":"equity/#Geometric-Brownian-Motion","page":"Equity securities","title":"Geometric Brownian Motion","text":"","category":"section"},{"location":"equity/","page":"Equity securities","title":"Equity securities","text":"VLQuantitativeFinancePackage.MyGeometricBrownianMotionEquityModel\nVLQuantitativeFinancePackage.MyMultipleAssetGeometricBrownianMotionEquityModel\nVLQuantitativeFinancePackage.build(model::Type{MyGeometricBrownianMotionEquityModel}, data::NamedTuple)\nVLQuantitativeFinancePackage.build(model::Type{MyMultipleAssetGeometricBrownianMotionEquityModel}, data::NamedTuple)\nVLQuantitativeFinancePackage.sample(model::MyGeometricBrownianMotionEquityModel, data::NamedTuple; \n    number_of_paths::Int64 = 100)\nVLQuantitativeFinancePackage.sample(model::MyMultipleAssetGeometricBrownianMotionEquityModel, data::NamedTuple; \n    number_of_paths::Int64 = 100)\nVLQuantitativeFinancePackage.sample_endpoint(model::MyGeometricBrownianMotionEquityModel, data::NamedTuple; \n    number_of_paths::Int64 = 100)","category":"page"},{"location":"equity/#VLQuantitativeFinancePackage.MyGeometricBrownianMotionEquityModel","page":"Equity securities","title":"VLQuantitativeFinancePackage.MyGeometricBrownianMotionEquityModel","text":"mutable struct MyGeometricBrownianMotionEquityModel <: AbstractAssetModel\n\nThe MyGeometricBrownianMotionEquityModel mutable struct represents a geometric Brownian motion model for  a single equity asset.\n\nFields\n\nμ::Float64: The drift rate of the asset price\nσ::Float64: The volatility of the asset price\n\n\n\n\n\n","category":"type"},{"location":"equity/#VLQuantitativeFinancePackage.MyMultipleAssetGeometricBrownianMotionEquityModel","page":"Equity securities","title":"VLQuantitativeFinancePackage.MyMultipleAssetGeometricBrownianMotionEquityModel","text":"mutable struct MyMultipleAssetGeometricBrownianMotionEquityModel <: AbstractAssetModel\n\nThe MyMultipleAssetGeometricBrownianMotionEquityModel mutable struct represents a geometric Brownian motion model for multiple equity assets. \n\nFields\n\nμ::Array{Float64,1}: The drift rates of the asset prices\nA::Array{Float64,2}: The Cholesky decomposition of the covariance matrix between the asset returns.\n\n\n\n\n\n","category":"type"},{"location":"equity/#VLQuantitativeFinancePackage.build-Tuple{Type{MyGeometricBrownianMotionEquityModel}, NamedTuple}","page":"Equity securities","title":"VLQuantitativeFinancePackage.build","text":"build(model::Type{MyGeometricBrownianMotionEquityModel}, data::NamedTuple) -> MyGeometricBrownianMotionEquityModel\n\nThis build method constructs an instance of the MyGeometricBrownianMotionEquityModel type using the data in a NamedTuple.\n\nArguments\n\nmodel::Type{MyGeometricBrownianMotionEquityModel}: The type of model to build.\ndata::NamedTuple: The data to use to build the model.\n\nThe data::NamedTuple must contain the following keys:\n\nμ::Float64: The drift of the process.\nσ::Float64: The volatility of the process.\n\n\n\n\n\n","category":"method"},{"location":"equity/#VLQuantitativeFinancePackage.build-Tuple{Type{MyMultipleAssetGeometricBrownianMotionEquityModel}, NamedTuple}","page":"Equity securities","title":"VLQuantitativeFinancePackage.build","text":"build(model::Type{MyMultipleAssetGeometricBrownianMotionEquityModel}, data::NamedTuple) -> MyMultipleAssetGeometricBrownianMotionEquityModel\n\nThis build method constructs an instance of the MyMultipleAssetGeometricBrownianMotionEquityModel type using the data in a NamedTuple.\n\nArguments\n\nmodel::Type{MyMultipleAssetGeometricBrownianMotionEquityModel}: The type of model to build.\ndata::NamedTuple: The data to use to build the model.\n\nThe data::NamedTuple must contain the following keys:\n\nμ::Array{Float64,1}: Array of drift rates for each asset.\nA::Array{Float64,2}: Cholesky decomposition of the covariance matrix of the process.\n\n\n\n\n\n","category":"method"},{"location":"equity/#VLQuantitativeFinancePackage.sample-Tuple{MyGeometricBrownianMotionEquityModel, NamedTuple}","page":"Equity securities","title":"VLQuantitativeFinancePackage.sample","text":"sample(model::MyGeometricBrownianMotionEquityModel, data::NamedTuple; \n    number_of_paths::Int64 = 100) -> Array{Float64,2}\n\nThe sample function simulates the geometric Brownian motion model for a single equity using the analytical solution. The model is defined by the parameters μ and σ which are the drift and volatility of the equity return, respectively. The simulation is performed over a time interval T and the initial price of the equity is Sₒ.  The function returns a matrix of size (number_of_time_steps, number_of_paths + 1) where each row represents a single path of the equity price over time.\n\nArguments\n\nmodel::MyGeometricBrownianMotionEquityModel: An instance of the MyGeometricBrownianMotionEquityModel type which models the geometric Brownian motion for the equity.\ndata::NamedTuple: A named tuple that contains the data for the simulation. \n\nThe data::NamedTuple must contain the following keys:\n\nT₁::Float64: The start time of the simulation.\nT₂::Float64: The end time of the simulation.\nΔt::Float64: The time increment for the simulation.\nSₒ::Float64: The initial price of the equity.\n\nReturns\n\nArray{Float64,2}: A matrix of size (number_of_time_steps, number_of_paths + 1) where each row represents a single path of the equity price over time. The first column contains the time values.\n\nOptional Arguments\n\nnumber_of_paths::Int64 = 100: The number of paths to simulate. Default value is 100 paths.\n\n\n\n\n\n","category":"method"},{"location":"equity/#VLQuantitativeFinancePackage.sample-Tuple{MyMultipleAssetGeometricBrownianMotionEquityModel, NamedTuple}","page":"Equity securities","title":"VLQuantitativeFinancePackage.sample","text":"sample(model::MyMultipleAssetGeometricBrownianMotionEquityModel, data::NamedTuple; \n    number_of_paths::Int64 = 100) -> Dict{Int64, Array{Float64,2}}\n\nThe sample function simulates the geometric Brownian motion model for multiple equities using the analytical solution.\n\nArguments\n\nmodel::MyMultipleAssetGeometricBrownianMotionEquityModel: An instance of the MyMultipleAssetGeometricBrownianMotionEquityModel type which models the geometric Brownian motion for multiple equities.\ndata::NamedTuple: A named tuple that contains the data for the simulation.\n\nThe data::NamedTuple must contain the following keys:\n\nT₁::Float64: The start time of the simulation.\nT₂::Float64: The end time of the simulation.\nΔt::Float64: The time increment for the simulation.\nSₒ::Array{Float64,1}: The initial prices of the equities.\n\nReturns\n\nDict{Int64, Array{Float64,2}}: A dictionary of simulations where the key is the path index and the value is a matrix of size (number_of_time_steps, number_of_assets + 1) where each row represents a time step, and columns represents an asset price. The first column contains the time values.\n\n\n\n\n\n","category":"method"},{"location":"equity/#VLQuantitativeFinancePackage.sample_endpoint-Tuple{MyGeometricBrownianMotionEquityModel, NamedTuple}","page":"Equity securities","title":"VLQuantitativeFinancePackage.sample_endpoint","text":"sample_endpoint(model::MyGeometricBrownianMotionEquityModel, data::NamedTuple; \n    number_of_paths::Int64 = 100) -> Array{Float64,1}\n\nThe sample_endpoint function simulates the geometric Brownian motion model for a single equity using the analytical solution at time T.\n\nArguments\n\nmodel::MyGeometricBrownianMotionEquityModel: An instance of the MyGeometricBrownianMotionEquityModel type which models the geometric Brownian motion for the equity.\ndata::NamedTuple: A named tuple that contains the data for the simulation.\n\nThe data::NamedTuple must contain the following keys:\n\nT::Float64: The time at which to sample the equity price.\nSₒ::Float64: The initial price of the equity at time 0.\n\nReturns\n\nArray{Float64,1}: An array of size number_of_paths that contains the equity price at time T.\n\nOptional Arguments\n\nnumber_of_paths::Int64 = 100: The number of paths to simulate. Default value is 100 paths.\n\n\n\n\n\n","category":"method"},{"location":"equity/#Advanced-Stochastic-Pricing-and-Return-Models","page":"Equity securities","title":"Advanced Stochastic Pricing and Return Models","text":"","category":"section"},{"location":"equity/","page":"Equity securities","title":"Equity securities","text":"VLQuantitativeFinancePackage.EulerMaruyamaMethod\nVLQuantitativeFinancePackage.MyOrnsteinUhlenbeckModel\nVLQuantitativeFinancePackage.MyHestonModel\nVLQuantitativeFinancePackage.build(model::Type{MyOrnsteinUhlenbeckModel}, data::NamedTuple)\nVLQuantitativeFinancePackage.build(model::Type{MyHestonModel}, data::NamedTuple)\nVLQuantitativeFinancePackage.solve(model::AbstractAssetModel, tspan::NamedTuple,\n    initialconditions::AbstractArray; method::AbstractStochasticSolverModel = EulerMaruyamaMethod(), \n    N::Int64 = 100)","category":"page"},{"location":"equity/#VLQuantitativeFinancePackage.EulerMaruyamaMethod","page":"Equity securities","title":"VLQuantitativeFinancePackage.EulerMaruyamaMethod","text":"struct EulerMaruyamaMethod <: AbstractStochasticSolverModel\n\nImmutable type that represents the Euler-Maruyama method for solving stochastic differential equations. This type is passed to various functions in their method argument to indicate that the Euler-Maruyama method  should be used in calculations.\n\n\n\n\n\n","category":"type"},{"location":"equity/#VLQuantitativeFinancePackage.MyOrnsteinUhlenbeckModel","page":"Equity securities","title":"VLQuantitativeFinancePackage.MyOrnsteinUhlenbeckModel","text":"mutable struct MyOrnsteinUhlenbeckModel <: AbstractAssetModel\n\nA mutable struct that represents a Ornstein-Uhlenbeck process. An instance of MyOrnsteinUhlenbeckModel is configured and constructed using a corresponding build method.\n\nFields\n\nμ::Function: The price drift function (long term price level)\nσ::Function: The price volatility function\nθ::Function: The mean reversion function. This function determines how quickly the price reverts to the long-term mean.\n\n\n\n\n\n","category":"type"},{"location":"equity/#VLQuantitativeFinancePackage.MyHestonModel","page":"Equity securities","title":"VLQuantitativeFinancePackage.MyHestonModel","text":"mutable struct MyHestonModel <: AbstractAssetModel\n\nA mutable struct that represents the Heston model.  An instance of MyHestonModel is configured and constructed using a corresponding build method.\n\nFields\n\nμ::Function: Drift function takes the state matrix X and time t and returns a scalar, i.e., muXtimestrightarrowmathbbR\nκ::Function: Mean reversion function\nθ::Function: Long-run volatility function\nξ::Function: Volatility of volatility function\nΣ::Array{Float64,2}: Covariance matrix between the asset price and the volatility process\n\n\n\n\n\n","category":"type"},{"location":"equity/#VLQuantitativeFinancePackage.build-Tuple{Type{MyOrnsteinUhlenbeckModel}, NamedTuple}","page":"Equity securities","title":"VLQuantitativeFinancePackage.build","text":"build(modeltype::Type{MyOrnsteinUhlenbeckModel}, data::NamedTuple) -> MyOrnsteinUhlenbeckModel\n\nThis method builds an instance of the MyOrnsteinUhlenbeckModel type using the data in a NamedTuple.\n\nArguments\n\nmodeltype::Type{MyOrnsteinUhlenbeckModel}: The type of model to build.\ndata::NamedTuple: The data to use to build the model. \n\nThe data::NamedTuple argument must contain the following keys:\n\nμ::Float64: The long-term mean of the process.\nσ::Float64: The volatility of the process.\nθ::Float64: The mean reversion rate of the process.\n\n\n\n\n\n","category":"method"},{"location":"equity/#VLQuantitativeFinancePackage.build-Tuple{Type{MyHestonModel}, NamedTuple}","page":"Equity securities","title":"VLQuantitativeFinancePackage.build","text":"build(model::Type{MyHestonModel}, data::NamedTuple) -> MyHestonModel\n\nThis build method constructs an instance of the MyHestonModel type using the data in a NamedTuple.\n\nArguments\n\nmodel::Type{MyHestonModel}: The type of model to build.\ndata::NamedTuple: The data to use to build the model. \n\nThe data::NamedTuple must contain the following keys:\n\nμ::Function: The long-term mean of the process.\nκ::Function: The mean reversion rate of the process.\nθ::Function: The volatility of the process.\nξ::Function: The volatility of the volatility of the process.\nΣ::Array{Float64,2}: The covariance matrix of the process.\n\n\n\n\n\n","category":"method"},{"location":"equity/#VLQuantitativeFinancePackage.solve-Tuple{AbstractAssetModel, NamedTuple, AbstractArray}","page":"Equity securities","title":"VLQuantitativeFinancePackage.solve","text":"solve(model::AbstractAssetModel, tspan::NamedTuple, initialconditions::AbstractArray; \n    method::AbstractStochasticSolverModel = EulerMaruyamaMethod(), N::Int64 = 100)::Tuple\n\nThe solve function is used to solve a stochastic asset model.  The function takes a model, time span, initial conditions, method, and number of paths as input and returns a tuple of time and state arrays.  The method argument is used to specify the method used to solve the model. The N argument is used to specify the number of paths to simulate.  The function uses the Euler-Maruyama method as the default method to solve the model.\n\nArguments\n\nmodel::AbstractAssetModel: The asset model to solve.\ntspan::NamedTuple: The time span to solve the model over. The NamedTuple should have the fields start, stop, and step.\ninitialconditions::AbstractArray: The initial conditions for the model.\nmethod::AbstractStochasticSolverModel = EulerMaruyamaMethod(): The method used to solve the model. Default is Euler-Maruyama.\nN::Int64 = 100: The number of paths to simulate. Default is 100 paths.\n\nReturn\n\nTuple: A tuple of time and state arrays (more than one with multidimensional models) where the rows are the time steps and the columns are the paths. \n\n\n\n\n\n","category":"method"},{"location":"equity/#Structured-State-Space-Models","page":"Equity securities","title":"Structured State-Space Models","text":"","category":"section"},{"location":"equity/","page":"Equity securities","title":"Equity securities","text":"Update this section with some groooovy text.","category":"page"},{"location":"equity/","page":"Equity securities","title":"Equity securities","text":"VLQuantitativeFinancePackage.MySisoLegSHippoModel\nVLQuantitativeFinancePackage.build(model::Type{MySisoLegSHippoModel}, data::NamedTuple)\nVLQuantitativeFinancePackage.solve(model::MySisoLegSHippoModel, tspan::NamedTuple, signal::Array{Float64})\nVLQuantitativeFinancePackage.prediction(model::MySisoLegSHippoModel, tspan::NamedTuple, signal::Array{Float64,1};\n    S::Int64 = 10, B::Float64 = 40.0, α::Float64 = 0.25, β::Float64 = 0.10)\nVLQuantitativeFinancePackage.estimate_hippo_parameters(model::MySisoLegSHippoModel, tspan::NamedTuple, \n    signal::Array{Float64}; method = LBFGS())","category":"page"},{"location":"equity/#VLQuantitativeFinancePackage.MySisoLegSHippoModel","page":"Equity securities","title":"VLQuantitativeFinancePackage.MySisoLegSHippoModel","text":"mutable struct MySisoLegSHippoModel <: AbstractAssetModel\n\nA mutable struct that represents a single-input, single-output (SISO) linear time-invariant (LTI) system that used the Leg-S parameterization. An instance of MySisoLegSHippoModel is configuired and constructed using a corresponding build method.\n\nFields\n\nÂ::Array{Float64,2}: Discretized state matrix of the system Â ∈ ℝ^(n x n) where n is the number of hidden states\nB̂::Array{Float64,1}: Discretized input matrix of the system B̂ ∈ ℝ^n x 1\nĈ::Array{Float64,1}: Discretized output matrix of the system Ĉ ∈ ℝ^1 x n\nD̂::Array{Float64,1}: Discretized feedforward matrix of the system D̂ ∈ ℝ^1 x 1\nn::Int: Number of hidden states in the system\nXₒ::Array{Float64,1}: Initial conditions of the system\n\n\n\n\n\n","category":"type"},{"location":"equity/#VLQuantitativeFinancePackage.build-Tuple{Type{MySisoLegSHippoModel}, NamedTuple}","page":"Equity securities","title":"VLQuantitativeFinancePackage.build","text":"build(modeltype::Type{MySisoLegSHippoModel}, data::NamedTuple) -> MySisoLegSHippoModel\n\nThis build method constructs an instance of the MySisoLegSHippoModel type using the data in a NamedTuple. This implementation uses the bilinear method to discretize the model, where the A and B matrices are computed using the Leg-S parameterization.\n\nArguments\n\nmodeltype::Type{MySisoLegSHippoModel}: The type of model to build.\ndata::NamedTuple: The data to use to build the model. \n\nThe data::NamedTuple must contain the following keys:\n\nnumber_of_hidden_states::Int64: The number of hidden states in the model.\nΔt::Float64: The time step size used to discretize the model (constant).\nuₒ::Array{Float64,1}: The initial input to the model.\nC::Array{Float64,1}: The output matrix of the model.\n\n\n\n\n\n","category":"method"},{"location":"equity/#VLQuantitativeFinancePackage.solve-Tuple{MySisoLegSHippoModel, NamedTuple, Array{Float64}}","page":"Equity securities","title":"VLQuantitativeFinancePackage.solve","text":"solve(model::MySisoLegSHippoModel, tspan::NamedTuple, signal::Array{Float64}) -> Tuple\n\nThe solve function solves the single input single output (SISO) HiPPO model using the Leg-S parameterization and  bilinear discretization. The function returns the time array, the hidden state array and the output array.\n\nArguments\n\nmodel::MySisoLegSHippoModel: A model struct that defines the HiPPO model, see MySisoLegSHippoModel for details on the model struct.\ntspan::NamedTuple: A named tuple that defines the time span for the simulation. The named tuple should have the fields start, stop and step.\nsignal::Array{Float64}: An array of input signals to the model.\n\nReturns\n\nTuple: A tuple of the time array T, hidden state array X and the output array Y.\n\n\n\n\n\n","category":"method"},{"location":"equity/#VLQuantitativeFinancePackage.prediction-Tuple{MySisoLegSHippoModel, NamedTuple, Vector{Float64}}","page":"Equity securities","title":"VLQuantitativeFinancePackage.prediction","text":"prediction(model::MySisoLegSHippoModel, tspan::NamedTuple, signal::Array{Float64,1}; L::Int64 = 10) -> Tuple\n\nThe prediction function predicts the output of the single input single output (SISO) HiPPO model given a signal vector using the Leg-S parameterization and bilinear discretization.  The function returns the time array, the hidden state array and the output array. \n\nArguments\n\nmodel::MySisoLegSHippoModel: A model struct that defines the HiPPO model, see MySisoLegSHippoModel for details on the model struct.\ntspan::NamedTuple: A named tuple that defines the time span for the simulation. The named tuple should have the fields start, stop and step.\nsignal::Array{Float64}: An array of input signals to the model.\nS::Int64: Circular buffer size used by the prediction function. The default value is 10 steps. After L steps, the input signal is reset to the first signal value.\nB::Float64: A threshold value used to reset the hidden states. The default value is 40.0.\nα::Float64: A scaling factor used to check the output value. The default value is 0.25.\nβ::Float64: A scaling factor used to reset the hidden states. The default value is 0.10.\n\nReturns\n\nTuple: A tuple of the time array T, hidden state array X and the output array Y.\n\n\n\n\n\n","category":"method"},{"location":"equity/#VLQuantitativeFinancePackage.estimate_hippo_parameters-Tuple{MySisoLegSHippoModel, NamedTuple, Array{Float64}}","page":"Equity securities","title":"VLQuantitativeFinancePackage.estimate_hippo_parameters","text":"estimate_hippo_parameters(model::MySisoLegSHippoModel, tspan::NamedTuple, signal::Array{Float64};\n    method = LBFGS()) -> Array{Float64}\n\nThe estimate_hippo_parameters function estimates the C-matrix of the single input single output (SISO)  Leg-S bilinear discretized HiPPO model. The Optim.jl package is used to minimize the squared error loss between the estimated and observed model output. The function returns the estimated parameters.\n\nArguments\n\nmodel::MySisoLegSHippoModel: A model struct that defines the HiPPO model, see MySisoLegSHippoModel for details on the model struct.\ntspan::NamedTuple: A named tuple that defines the time span for the simulation. The named tuple should have the fields start, stop and step.\nsignal::Array{Float64}: An array of input signals to the model.\nmethod::AbstractOptimizer: An optimizer to use for the optimization problem. The default optimizer is the LBFGS routine of the Optim.jl.\n\nReturns\n\nArray{Float64}: An array of estimated parameters for the C-matrix of the HiPPO model\n\n\n\n\n\n","category":"method"},{"location":"portfolio/#Portfolio-management","page":"Portfolio management","title":"Portfolio management","text":"","category":"section"},{"location":"portfolio/","page":"Portfolio management","title":"Portfolio management","text":"Fill me in","category":"page"},{"location":"portfolio/","page":"Portfolio management","title":"Portfolio management","text":"VLQuantitativeFinancePackage.MyMarkowitzRiskyAssetOnlyPortfiolioChoiceProblem\nVLQuantitativeFinancePackage.MyMarkowitzRiskyRiskFreePortfiolioChoiceProblem\nVLQuantitativeFinancePackage.MySingleIndexModel\nVLQuantitativeFinancePackage.build(model::Type{MyMarkowitzRiskyAssetOnlyPortfiolioChoiceProblem}, data::NamedTuple)\nVLQuantitativeFinancePackage.build(model::Type{MyMarkowitzRiskyRiskFreePortfiolioChoiceProblem}, data::NamedTuple)\nVLQuantitativeFinancePackage.build(model::Type{MySingleIndexModel}, data::NamedTuple)\nVLQuantitativeFinancePackage.solve(model::MyMarkowitzRiskyAssetOnlyPortfiolioChoiceProblem)\nVLQuantitativeFinancePackage.solve(model::MyMarkowitzRiskyRiskFreePortfiolioChoiceProblem)","category":"page"},{"location":"portfolio/#VLQuantitativeFinancePackage.MyMarkowitzRiskyAssetOnlyPortfiolioChoiceProblem","page":"Portfolio management","title":"VLQuantitativeFinancePackage.MyMarkowitzRiskyAssetOnlyPortfiolioChoiceProblem","text":"mutable struct MyMarkowitzRiskyAssetOnlyPortfiolioChoiceProblem <: AbstractStochasticChoiceProblem\n\nThe MyMarkowitzRiskyAssetOnlyPortfiolioChoiceProblem mutable struct represents a Minimum Variance portfolio problem with risky assets only.\n\nRequired fields\n\nΣ::Array{Float64,2}: The covariance matrix of the risky asset Returns\nμ::Array{Float64,1}: The expected returns of the risky assets\nbounds::Array{Float64,2}: The bounds on the risky asset weights\nR::Float64: The desired return of the portfolio\ninitial::Array{Float64,1}: The initial portfolio weights    \n\n\n\n\n\n","category":"type"},{"location":"portfolio/#VLQuantitativeFinancePackage.MyMarkowitzRiskyRiskFreePortfiolioChoiceProblem","page":"Portfolio management","title":"VLQuantitativeFinancePackage.MyMarkowitzRiskyRiskFreePortfiolioChoiceProblem","text":"mutable struct MyMarkowitzRiskyRiskFreePortfiolioChoiceProblem <: AbstractStochasticChoiceProblem\n\nThe MyMarkowitzRiskyRiskFreePortfiolioChoiceProblem mutable struct represents a Minimum Variance portfolio problem with a combination of risky and risk-free assets. \n\nRequired fields\n\nΣ::Array{Float64,2}: The covariance matrix of the risky asset returns\nμ::Array{Float64,1}: The expected returns of the risky assets\nbounds::Array{Float64,2}: The bounds on the risky asset weights\nR::Float64: The desired return of the portfolio\ninitial::Array{Float64,1}: The initial portfolio weights\nrisk_free_rate::Float64: The risk-free rate of return\n\n\n\n\n\n","category":"type"},{"location":"portfolio/#VLQuantitativeFinancePackage.MySingleIndexModel","page":"Portfolio management","title":"VLQuantitativeFinancePackage.MySingleIndexModel","text":"mutable struct MySingleIndexModel <: AbstractReturnModel\n\nThe MySingleIndexModel mutable struct represents a single index model of risky asset returns.\n\nRequired fields\n\nα::Float64: The firm specific unexplained return\nβ::Float64: The relationship between the firm and the market\nr::Float64: The risk-free rate of return\nϵ::Distribution: The random shocks to the model (unexplained return)    \n\n\n\n\n\n","category":"type"},{"location":"portfolio/#VLQuantitativeFinancePackage.build-Tuple{Type{MyMarkowitzRiskyAssetOnlyPortfiolioChoiceProblem}, NamedTuple}","page":"Portfolio management","title":"VLQuantitativeFinancePackage.build","text":"build(model::Type{MyMarkowitzRiskyAssetOnlyPortfiolioChoiceProblem}, data::NamedTuple)  -> MyMarkowitzRiskyAssetOnlyPortfiolioChoiceProblem\n\nThis build method constructs an instance of the MyMarkowitzRiskyAssetOnlyPortfiolioChoiceProblem type using the data in a NamedTuple.\n\nArguments\n\nmodel::Type{MyMarkowitzRiskyAssetOnlyPortfiolioChoiceProblem}: The type of model to build.\ndata::NamedTuple: The data to use to build the model.\n\nThe data::NamedTuple must contain the following keys:\n\nμ::Array{Float64,1}: The drift rates of the assets.\n\n\n\n\n\n","category":"method"},{"location":"portfolio/#VLQuantitativeFinancePackage.build-Tuple{Type{MyMarkowitzRiskyRiskFreePortfiolioChoiceProblem}, NamedTuple}","page":"Portfolio management","title":"VLQuantitativeFinancePackage.build","text":"build(model::Type{MyMarkowitzRiskyRiskFreePortfiolioChoiceProblem}, data::NamedTuple) -> MyMarkowitzRiskyRiskFreePortfiolioChoiceProblem\n\nThis build method constructs an instance of the MyMarkowitzRiskyRiskFreePortfiolioChoiceProblem type using the data in a NamedTuple.\n\nArguments\n\nmodel::Type{MyMarkowitzRiskyRiskFreePortfiolioChoiceProblem}: The type of model to build.\ndata::NamedTuple: The data to use to build the model.\n\nThe data::NamedTuple must contain the following keys:\n\nΣ::Array{Float64,2}: The covariance matrix of the risky asset returns\nμ::Array{Float64,1}: The expected returns of the risky assets\nbounds::Array{Float64,2}: The bounds on the risky asset weights\nR::Float64: The desired return of the portfolio\ninitial::Array{Float64,1}: The initial portfolio weights\nrisk_free_rate::Float64: The risk-free rate of return\n\n\n\n\n\n","category":"method"},{"location":"portfolio/#VLQuantitativeFinancePackage.build-Tuple{Type{MySingleIndexModel}, NamedTuple}","page":"Portfolio management","title":"VLQuantitativeFinancePackage.build","text":"build(model::Type{MySingleIndexModel}, data::NamedTuple) -> MySingleIndexModel\n\nThis build method constructs an instance of the MySingleIndexModel type using the data in a NamedTuple.\n\nArguments\n\nmodel::Type{MySingleIndexModel}: The type of model to build.\ndata::NamedTuple: The data to use to build the model.\n\nThe data::NamedTuple must contain the following keys:\n\nα::Float64: The firm specific unexplained return\nβ::Float64: The relationship between the firm and the market\nr::Float64: The risk-free rate of return\nϵ::Distribution: The random shocks to the model (unexplained return) \n\nReturn\n\nThis function returns an instance of the MySingleIndexModel type. \n\nSee also:\n\nThe unexplained return is modeled as a random variable, and the user can specify the distribution of this variable using the ϵ::Distribution argument.\n\nSee the Distributions.jl package package for more information on the available distributions.\n\n\n\n\n\n","category":"method"},{"location":"portfolio/#VLQuantitativeFinancePackage.solve-Tuple{MyMarkowitzRiskyAssetOnlyPortfiolioChoiceProblem}","page":"Portfolio management","title":"VLQuantitativeFinancePackage.solve","text":"solve(problem::MyMarkowitzRiskyAssetOnlyPortfiolioChoiceProblem) -> Dict{String,Any}\n\nThe solve function solves the Markowitz risky asset-only portfolio choice problem for a given instance of the MyMarkowitzRiskyAssetOnlyPortfiolioChoiceProblem problem type. The solve method checks for the status of the optimization using an assertion, thus, the optimization must be successful for the function to return. Wrap the function call in a try block to handle exceptions.\n\nArguments\n\nproblem::MyMarkowitzRiskyAssetOnlyPortfiolioChoiceProblem: An instance of the MyMarkowitzRiskyAssetOnlyPortfiolioChoiceProblem that defines the problem parameters.\n\nReturns\n\nDict{String,Any}: A dictionary that holds the results of the optimization.\n\nThe results dictionary has the following keys:\n\n\"reward\": The reward associated with the optimal portfolio.\n\"argmax\": The optimal portfolio weights.\n\"objective_value\": The value of the objective function at the optimal solution.\n\"status\": The status of the optimization.\n\n\n\n\n\n","category":"method"},{"location":"portfolio/#VLQuantitativeFinancePackage.solve-Tuple{MyMarkowitzRiskyRiskFreePortfiolioChoiceProblem}","page":"Portfolio management","title":"VLQuantitativeFinancePackage.solve","text":"solve(problem::MyMarkowitzRiskyRiskFreePortfiolioChoiceProblem) -> Dict{String,Any}\n\nThe solve function solves the Markowitz risky and risk-free portfolio choice problem for a given instance of the MyMarkowitzRiskyRiskFreePortfiolioChoiceProblem problem type. The solve method checks for the status of the optimization using an assertion, thus, the optimization must be successful for the function to return. Wrap the function call in a try block to handle exceptions.\n\nArguments\n\nproblem::MyMarkowitzRiskyRiskFreePortfiolioChoiceProblem: An instance of the MyMarkowitzRiskyRiskFreePortfiolioChoiceProblem that defines the problem parameters.\n\nReturns\n\nDict{String,Any}: A dictionary that holds the results of the optimization. \n\nThe results dictionary has the following keys:\n\n\"reward\": The reward associated with the optimal portfolio.\n\"argmax\": The optimal portfolio weights.\n\"objective_value\": The value of the objective function at the optimal solution.\n\"status\": The status of the optimization.\n\n\n\n\n\n","category":"method"},{"location":"fixed/#Fixed-Income-Treasury-Securities","page":"Treasury securities","title":"Fixed Income Treasury Securities","text":"","category":"section"},{"location":"fixed/","page":"Treasury securities","title":"Treasury securities","text":"Fixed income securities are financial instruments that pay a fixed amount of interest over a specified period of time. The most common fixed income securities are bonds, which are issued by governments, municipalities, and corporations. The fixed income market is one of the largest financial markets in the world, and it plays a critical role in the global economy.","category":"page"},{"location":"fixed/#Discounting-moddel","page":"Treasury securities","title":"Discounting moddel","text":"","category":"section"},{"location":"fixed/","page":"Treasury securities","title":"Treasury securities","text":"In the VLQuantitativeFinancePackage we allow computing the present value of a cash flow stream using a discounting model. The present value of a cash flow stream can be computed using a ContinuousCompoundingModel or a DiscreteCompoundingModel.","category":"page"},{"location":"fixed/","page":"Treasury securities","title":"Treasury securities","text":"VLQuantitativeFinancePackage.DiscreteCompoundingModel\nVLQuantitativeFinancePackage.ContinuousCompoundingModel","category":"page"},{"location":"fixed/#VLQuantitativeFinancePackage.DiscreteCompoundingModel","page":"Treasury securities","title":"VLQuantitativeFinancePackage.DiscreteCompoundingModel","text":"struct DiscreteCompoundingModel <: AbstractCompoundingModel\n\nImmutable type that represents discrete compounding. This type has no fields and is passed as an argument to various functions to indicate that discrete compounding should be used in calculations.\n\n\n\n\n\n","category":"type"},{"location":"fixed/#VLQuantitativeFinancePackage.ContinuousCompoundingModel","page":"Treasury securities","title":"VLQuantitativeFinancePackage.ContinuousCompoundingModel","text":"struct ContinuousCompoundingModel <: AbstractCompoundingModel\n\nImmutable type that represents continuous compounding.  This type has no fields and is passed as an argument to various functions to indicate that continuous compounding should be used in calculations.\n\n\n\n\n\n","category":"type"},{"location":"fixed/#Treasury-secruity-model-types","page":"Treasury securities","title":"Treasury secruity model types","text":"","category":"section"},{"location":"fixed/","page":"Treasury securities","title":"Treasury securities","text":"We model United States Treasury debt securities, e.g., Treasury bills, Treasury notes, and Treasury bonds using  the MyUSTreasuryZeroCouponBondModel and MyUSTreasuryCouponSecurityModel types, which are subtypes of the AbstractTreasuryDebtSecurity abstract type.  ","category":"page"},{"location":"fixed/","page":"Treasury securities","title":"Treasury securities","text":"VLQuantitativeFinancePackage.MyUSTreasuryZeroCouponBondModel\nVLQuantitativeFinancePackage.MyUSTreasuryCouponSecurityModel\nVLQuantitativeFinancePackage.build(model::Type{MyUSTreasuryZeroCouponBondModel}, data::NamedTuple)\nVLQuantitativeFinancePackage.build(model::Type{MyUSTreasuryCouponSecurityModel}, data::NamedTuple)","category":"page"},{"location":"fixed/#VLQuantitativeFinancePackage.MyUSTreasuryZeroCouponBondModel","page":"Treasury securities","title":"VLQuantitativeFinancePackage.MyUSTreasuryZeroCouponBondModel","text":"mutable struct MyUSTreasuryZeroCouponBondModel <: AbstractTreasuryDebtSecurity\n\nA mutable struct that represents a U.S. Treasury zero coupon security. \n\nFields\n\npar::Float64: The face or par value of the bond\nrate::Union{Nothing, Float64}: Effective annual interest rate (discount rate specified as a decimal)\nT::Union{Nothing,Float64}: Duration in years of the instrument, measured as a 365 day or a 52 week year\nn::Int: Number of compounding periods per year (typically 2)\n\nComputed Fields\n\nprice::Union{Nothing, Float64}: Price of the bond or note (computed property)\ncashflow::Union{Nothing, Dict{Int,Float64}}: Cashflow dictionary (computed property) where the key is the period and the value is the discounted cashflow in a period\ndiscount::Union{Nothing, Dict{Int,Float64}}: Discount factor dictionary (computed property) where the key is the period and the value is the discount factor in that period\n\n\n\n\n\n","category":"type"},{"location":"fixed/#VLQuantitativeFinancePackage.MyUSTreasuryCouponSecurityModel","page":"Treasury securities","title":"VLQuantitativeFinancePackage.MyUSTreasuryCouponSecurityModel","text":"mutable struct MyUSTreasuryCouponSecurityModel <: AbstractTreasuryDebtSecurity\n\nA mutable struct that represents a U.S. Treasury coupon bond.  This type of security (note or bond) pays the holder of the instrument a fixed interest rate at regular intervals over the life of the security.\n\nFields\n\npar::Float64: Par value of the bond\nrate::Union{Nothing, Float64}: Annualized effective discount rate\ncoupon::Union{Nothing, Float64}: Coupon interest rate\nT::Union{Nothing,Float64}: Duration in years of the note or bond, measured as a 365 day or a 52 week year\nλ::Int: Number of coupon payments per year (typically 2)\n\nComputed Fields\n\nprice::Union{Nothing, Float64}: Price of the bond or note (computed property)\ncashflow::Union{Nothing, Dict{Int,Float64}}: Cashflow dictionary (computed property) where the key is the period and the value is the discounted cashflow in a period\ndiscount::Union{Nothing, Dict{Int,Float64}}: Discount factor dictionary(computed property) where the key is the period and the value is the discount factor in that period\n\n\n\n\n\n","category":"type"},{"location":"fixed/#VLQuantitativeFinancePackage.build-Tuple{Type{MyUSTreasuryZeroCouponBondModel}, NamedTuple}","page":"Treasury securities","title":"VLQuantitativeFinancePackage.build","text":"build(model::Type{MyUSTreasuryZeroCouponBondModel}, data::NamedTuple) -> MyUSTreasuryZeroCouponBondModel\n\nThis build method constructs an instance of the MyUSTreasuryZeroCouponBondModel type using the  data in the NamedTuple argument.\n\nArguments\n\nmodel::Type{MyUSTreasuryZeroCouponBondModel}: The type of model to build.\ndata::NamedTuple: The data to use to build the model. \n\nThe data::NamedTuple argument must contain the following keys:\n\npar::Float64: The face or par value of the bond\nrate::Union{Nothing, Float64}: Effective annual interest rate (discount rate specified as a decimal)\nT::Union{Nothing,Float64}: Duration in years measured as a 365 day or a 52 week year\nn::Int: Number of compounding periods per year (typically 2)\n\n\n\n\n\n","category":"method"},{"location":"fixed/#VLQuantitativeFinancePackage.build-Tuple{Type{MyUSTreasuryCouponSecurityModel}, NamedTuple}","page":"Treasury securities","title":"VLQuantitativeFinancePackage.build","text":"build(model::Type{MyUSTreasuryCouponSecurityModel}, data::NamedTuple) -> MyUSTreasuryCouponSecurityModel\n\nThis build method constructs an instance of the MyUSTreasuryCouponSecurityModel type using the data in the NamedTuple.\n\nArguments\n\nmodel::Type{MyUSTreasuryCouponSecurityModel}: The type of model to build.\ndata::NamedTuple: The data to use to build the model. \n\nThe data::NamedTuple must contain the following keys:\n\npar::Float64: Par value of the bond\nrate::Union{Nothing, Float64}: Annualized effective discount rate\ncoupon::Union{Nothing, Float64}: Coupon interest rate\nT::Union{Nothing,Float64}: Duration in years of the note or bond, measured as a 365 day or a 52 week year\nλ::Int: Number of coupon payments per year (typically 2)\n\nReturn\n\nThis function returns an instance of the MyUSTreasuryCouponSecurityModel type.  To populate the model, use the price function or a short-cut function involving a compounding model.\n\nExample\n\nLet's build a MyUSTreasuryCouponSecurityModel instance and populate the price, cashflow and discount datastructures for a T = 20-yr  bond, with a coupon rate of c = 1.750%, a yield (discount rate) rate = 1.850%, two coupon payments per year, i.e., lambda = 2  and a face (par) value of V_P = 100 USD:\n\ntest_bond = build(MyUSTreasuryCouponSecurityModel, (\n    T = 20.0, rate = 0.01850, coupon = 0.01750, λ = 2, par = 100.0\n)) |> discount_model;\n\nwhere the discount_model refers to either a DiscreteCompoundingModel or a ContinuousCompoundingModel instance.\n\n\n\n\n\n","category":"method"},{"location":"fixed/#Computing-Treasury-security-prices","page":"Treasury securities","title":"Computing Treasury security prices","text":"","category":"section"},{"location":"fixed/","page":"Treasury securities","title":"Treasury securities","text":"To compute the price of a Treasury security, we use the price function that takes a AbstractTreasuryDebtSecurity object and a discounting model as input arguments. We construct MyUSTreasuryZeroCouponBondModel and MyUSTreasuryCouponSecurityModel objects by specifying the maturity date, the face value of the bond the effective annual interest rate and other data that are specific to the bill, note or bond in a build function where the data is specified in a NamedTuple format. ","category":"page"},{"location":"fixed/","page":"Treasury securities","title":"Treasury securities","text":"VLQuantitativeFinancePackage.price","category":"page"},{"location":"fixed/#VLQuantitativeFinancePackage.price","page":"Treasury securities","title":"VLQuantitativeFinancePackage.price","text":"price(model::MyUSTreasuryCouponSecurityModel, compounding::T) -> MyUSTreasuryCouponSecurityModel where T <: AbstractCompoundingModel\n\nThe price(...) function computes the price of a MyUSTreasuryCouponSecurityModel instance using a discrete or continuous compounding model.\n\nArguments\n\nmodel::MyUSTreasuryCouponSecurityModel: an instance of the MyUSTreasuryCouponSecurityModel type.\ncompounding::T: an instance of a type that is a subtype of AbstractCompoundingModel, i.e., a discrete or continuous compounding model.\n\nReturns\n\nMyUSTreasuryCouponSecurityModel: an updated instance of the MyUSTreasuryCouponSecurityModel type with the price computed using the compounding model.\n\n\n\n\n\nprice(model::MyUSTreasuryZeroCouponBondModel, compounding::T) -> MyUSTreasuryZeroCouponBondModel where T <: AbstractCompoundingModel\n\nThe price(...) function computes the price of a MyUSTreasuryZeroCouponBondModel instance using a discrete or continuous compounding model.\n\nArguments\n\nmodel::MyUSTreasuryZeroCouponBondModel: an instance of the MyUSTreasuryZeroCouponBondModel type.\ncompounding::T: an instance of a type that is a subtype of AbstractCompoundingModel, i.e., a discrete or continuous compounding model.\n\nReturns\n\nMyUSTreasuryZeroCouponBondModel: an updated instance of the MyUSTreasuryZeroCouponBondModel type with the price computed using the compounding model.\n\n\n\n\n\n","category":"function"},{"location":"fixed/#Short-cut-syntax","page":"Treasury securities","title":"Short-cut syntax","text":"","category":"section"},{"location":"fixed/","page":"Treasury securities","title":"Treasury securities","text":"We also provide a short-cut syntax to compute the price of a Treasury security which indirectly calls the price function. The short-cut syntax allows the user to specify the data required to construct a AbstractTreasuryDebtSecurity object, and then pass the data to the price function in a single call. ","category":"page"},{"location":"fixed/","page":"Treasury securities","title":"Treasury securities","text":"The short-cut syntax is as follows:","category":"page"},{"location":"fixed/","page":"Treasury securities","title":"Treasury securities","text":"(compounding::DiscreteCompoundingModel)(model::MyUSTreasuryCouponSecurityModel) = _price_discrete_compounding(model::MyUSTreasuryCouponSecurityModel)\n(compounding::ContinuousCompoundingModel)(model::MyUSTreasuryCouponSecurityModel) = _price_continuous_compounding(model::MyUSTreasuryCouponSecurityModel)\n(compounding::DiscreteCompoundingModel)(model::MyUSTreasuryZeroCouponBondModel) = _price_discrete_compounding(model::MyUSTreasuryZeroCouponBondModel)\n(compounding::ContinuousCompoundingModel)(model::MyUSTreasuryZeroCouponBondModel) = _price_continuous_compounding(model::MyUSTreasuryZeroCouponBondModel)","category":"page"},{"location":"fixed/","page":"Treasury securities","title":"Treasury securities","text":"To use the short-cut syntax, the user must first construct a AbstractTreasuryDebtSecurity object using the build function and then pass the object to the short-cut syntax function. For example, to compute the price of a 20-year Treasury bond with a coupon rate of 1.750%, a yield (discount rate) of 1.850%, two coupon payments per year, and a face value of 100 USD, the user can use the following code:","category":"page"},{"location":"fixed/","page":"Treasury securities","title":"Treasury securities","text":"test_bond = build(MyUSTreasuryCouponSecurityModel, (\n    T = 20.0, rate = 0.01850, coupon = 0.01750, λ = 2, par = 100.0\n)) |> discount_model;","category":"page"},{"location":"fixed/","page":"Treasury securities","title":"Treasury securities","text":"where the discount_model refers to either a DiscreteCompoundingModel or a ContinuousCompoundingModel instance.","category":"page"},{"location":"fixed/#Separating-the-principal-and-interest-payments","page":"Treasury securities","title":"Separating the principal and interest payments","text":"","category":"section"},{"location":"fixed/","page":"Treasury securities","title":"Treasury securities","text":"Registered Interest and Principal of Securities (STRIPS) bonds are a unique type of fixed-income investment instrument that provides investors with an alternative way to access the coupon payments of Treasury securities. STRIPS bonds are created by separating a Treasury securities coupon and principal components and trading them as individual  zero-coupon securities. This process allows investors to purchase and trade the coupon or principal components separately, providing greater flexibility in managing their investment portfolios.","category":"page"},{"location":"fixed/","page":"Treasury securities","title":"Treasury securities","text":"For example, a 5-year Treasury note with annual coupon payments of C USD and a face (par) value of V_P (USD) can be stripped into six separate zero-coupon securities, i.e., five zero-coupon bonds, each with face values of C  and maturity of T= 1,2,3,4 and 5 years, and a six security with face  (par) value of V_P USD with a duration of T = 5 years. In the general case, a treasury note or bond with N=lambdaT coupon payments, where T denotes the maturity in years, and lambda represents the number of coupon payments per year, can be stripped into N+1 separate zero-coupon securities.","category":"page"},{"location":"fixed/","page":"Treasury securities","title":"Treasury securities","text":"VLQuantitativeFinancePackage.strip","category":"page"},{"location":"fixed/#VLQuantitativeFinancePackage.strip","page":"Treasury securities","title":"VLQuantitativeFinancePackage.strip","text":"strip(model::MyUSTreasuryCouponSecurityModel) -> Dict{Int, MyUSTreasuryZeroCouponBondModel}\n\nStrips the coupon and par value payments from a parent coupon security. \n\nThe strip(...) function takes a model::MyUSTreasuryCouponSecurityModel of the security we wish to strip and returns a Dictionary  holding MyUSTreasuryZeroCouponBondModel instances created from the parent security.  The keys of the dictionary correspond to the temporal index of the created security.\n\n\n\n\n\n","category":"function"},{"location":"#VLQuantitativeFinancePackage.jl","page":"Home","title":"VLQuantitativeFinancePackage.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The VLQuantitativeFinancePackage.jl package is a Julia package that provides a collection of functions and types useful for quantitative finance. The package is designed to be simple and easy to use, and it is suitable for students, researchers, and practitioners in the area of quantitative finance.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed by running the following command in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/varnerlab/VLQuantitativeFinancePackage.jl.git\")","category":"page"},{"location":"#Disclaimer-and-Risks","page":"Home","title":"Disclaimer and Risks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This content is offered solely for training and informational purposes. No offer or solicitation to buy or sell securities or derivative products or any investment or trading advice or strategy is made, given, or endorsed by the teaching team. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Trading involves risk. Carefully review your financial situation before investing in securities, futures contracts, options, or commodity interests. Past performance, whether actual or indicated by historical tests of strategies, is no guarantee of future performance or success. Trading is generally inappropriate for someone with limited resources, investment or trading experience, or a low-risk tolerance.  Only risk capital that is not required for living expenses.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You are fully responsible for any investment or trading decisions you make. Such decisions should be based solely on evaluating your financial circumstances, investment or trading objectives, risk tolerance, and liquidity needs. You are responsible for conducting your own independent research and seeking the advice of a qualified professional before making any investment or trading decisions.","category":"page"},{"location":"markov/#Markov-Models","page":"Markov models","title":"Markov Models","text":"","category":"section"},{"location":"markov/","page":"Markov models","title":"Markov models","text":"Fill me in","category":"page"},{"location":"markov/","page":"Markov models","title":"Markov models","text":"VLQuantitativeFinancePackage.MyHiddenMarkovModel\nVLQuantitativeFinancePackage.build(model::Type{MyHiddenMarkovModel}, data::NamedTuple)","category":"page"},{"location":"markov/#VLQuantitativeFinancePackage.MyHiddenMarkovModel","page":"Markov models","title":"VLQuantitativeFinancePackage.MyHiddenMarkovModel","text":"mutable struct MyHiddenMarkovModel <: AbstractMarkovModel\n\nThe MyHiddenMarkovModel mutable struct represents a hidden Markov model (HMM) with discrete states.\n\nRequired fields\n\nstates::Array{Int64,1}: The states of the model\ntransition::Dict{Int64, Categorical}: The transition matrix of the model encoded as a dictionary where the key is the state and the value is a Categorical distribution\nemission::Dict{Int64, Categorical}: The emission matrix of the model encoded as a dictionary where the key is the state and the value is a Categorical distribution   \n\n\n\n\n\n","category":"type"},{"location":"markov/#VLQuantitativeFinancePackage.build-Tuple{Type{MyHiddenMarkovModel}, NamedTuple}","page":"Markov models","title":"VLQuantitativeFinancePackage.build","text":"build(model::Type{M}, data::NamedTuple) -> AbstractMarkovModel where {M <: AbstractMarkovModel}\n\nThis build method constructs a concrete instance of type M where M is a subtype of AbstractMarkovModel type using the data in a NamedTuple.\n\nArguments\n\nmodel::Type{M}: The type of model to build. This type must be a subtype of AbstractMarkovModel.\ndata::NamedTuple: The data to use to build the model.\n\nThe data::NamedTuple argument must contain the following keys:\n\nstates::Array{Int64,1}: The states of the model.\nT::Array{Float64,2}: The transition matrix of the model.\nE::Array{Float64,2}: The emission matrix of the model.\n\n\n\n\n\n","category":"method"}]
}
